<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React任务调度 | Zhoujc&#39;s blog</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="知识沉淀，好记性不如烂笔头">
    <link rel="preload" href="/assets/css/0.styles.a748b10c.css" as="style"><link rel="preload" href="/assets/js/app.ebc66fdf.js" as="script"><link rel="preload" href="/assets/js/2.d4b9d712.js" as="script"><link rel="preload" href="/assets/js/27.4b69f932.js" as="script"><link rel="prefetch" href="/assets/js/10.28e2e44c.js"><link rel="prefetch" href="/assets/js/100.6737e622.js"><link rel="prefetch" href="/assets/js/101.d01e975f.js"><link rel="prefetch" href="/assets/js/102.66a1ad64.js"><link rel="prefetch" href="/assets/js/103.0b7ae2db.js"><link rel="prefetch" href="/assets/js/104.20427db9.js"><link rel="prefetch" href="/assets/js/105.dd6e0546.js"><link rel="prefetch" href="/assets/js/106.71296a63.js"><link rel="prefetch" href="/assets/js/107.c378d5f1.js"><link rel="prefetch" href="/assets/js/11.e6454622.js"><link rel="prefetch" href="/assets/js/12.0e09de73.js"><link rel="prefetch" href="/assets/js/13.eb107cd6.js"><link rel="prefetch" href="/assets/js/14.6e619cc0.js"><link rel="prefetch" href="/assets/js/15.e0635319.js"><link rel="prefetch" href="/assets/js/16.a8da7a87.js"><link rel="prefetch" href="/assets/js/17.fbe39a52.js"><link rel="prefetch" href="/assets/js/18.bd853f5f.js"><link rel="prefetch" href="/assets/js/19.c8bd314a.js"><link rel="prefetch" href="/assets/js/20.3c574518.js"><link rel="prefetch" href="/assets/js/21.99a75cd7.js"><link rel="prefetch" href="/assets/js/22.42934391.js"><link rel="prefetch" href="/assets/js/23.8b82970c.js"><link rel="prefetch" href="/assets/js/24.7e974840.js"><link rel="prefetch" href="/assets/js/25.87e00c33.js"><link rel="prefetch" href="/assets/js/26.8b357711.js"><link rel="prefetch" href="/assets/js/28.766b5a05.js"><link rel="prefetch" href="/assets/js/29.aac35f3d.js"><link rel="prefetch" href="/assets/js/3.c3a1c082.js"><link rel="prefetch" href="/assets/js/30.ad955432.js"><link rel="prefetch" href="/assets/js/31.e4e4890f.js"><link rel="prefetch" href="/assets/js/32.6b284fe4.js"><link rel="prefetch" href="/assets/js/33.a22f85f8.js"><link rel="prefetch" href="/assets/js/34.5ac595eb.js"><link rel="prefetch" href="/assets/js/35.01736eef.js"><link rel="prefetch" href="/assets/js/36.63d4161d.js"><link rel="prefetch" href="/assets/js/37.ac568153.js"><link rel="prefetch" href="/assets/js/38.6ab48214.js"><link rel="prefetch" href="/assets/js/39.73e8152b.js"><link rel="prefetch" href="/assets/js/4.272a9fbd.js"><link rel="prefetch" href="/assets/js/40.2c194813.js"><link rel="prefetch" href="/assets/js/41.fe37b6f6.js"><link rel="prefetch" href="/assets/js/42.6f73345b.js"><link rel="prefetch" href="/assets/js/43.adc53b2c.js"><link rel="prefetch" href="/assets/js/44.310ae361.js"><link rel="prefetch" href="/assets/js/45.32e660b6.js"><link rel="prefetch" href="/assets/js/46.04890be7.js"><link rel="prefetch" href="/assets/js/47.4a68ffe5.js"><link rel="prefetch" href="/assets/js/48.90a9137b.js"><link rel="prefetch" href="/assets/js/49.58b6c3b6.js"><link rel="prefetch" href="/assets/js/5.f83283dc.js"><link rel="prefetch" href="/assets/js/50.043bd85d.js"><link rel="prefetch" href="/assets/js/51.c53db7d0.js"><link rel="prefetch" href="/assets/js/52.b419676d.js"><link rel="prefetch" href="/assets/js/53.36f713df.js"><link rel="prefetch" href="/assets/js/54.8002161b.js"><link rel="prefetch" href="/assets/js/55.cc1fc344.js"><link rel="prefetch" href="/assets/js/56.05a6ea6d.js"><link rel="prefetch" href="/assets/js/57.90a9d9ee.js"><link rel="prefetch" href="/assets/js/58.7b07447f.js"><link rel="prefetch" href="/assets/js/59.c17fc2f2.js"><link rel="prefetch" href="/assets/js/6.8a86adbf.js"><link rel="prefetch" href="/assets/js/60.66b80346.js"><link rel="prefetch" href="/assets/js/61.3a7ccc82.js"><link rel="prefetch" href="/assets/js/62.fb35378d.js"><link rel="prefetch" href="/assets/js/63.27e61864.js"><link rel="prefetch" href="/assets/js/64.64d01d10.js"><link rel="prefetch" href="/assets/js/65.a80a9fc0.js"><link rel="prefetch" href="/assets/js/66.5dc463c7.js"><link rel="prefetch" href="/assets/js/67.4a805afa.js"><link rel="prefetch" href="/assets/js/68.8287eee7.js"><link rel="prefetch" href="/assets/js/69.892294f6.js"><link rel="prefetch" href="/assets/js/7.5465fa65.js"><link rel="prefetch" href="/assets/js/70.e0ec7ddd.js"><link rel="prefetch" href="/assets/js/71.7256a53d.js"><link rel="prefetch" href="/assets/js/72.f96155a0.js"><link rel="prefetch" href="/assets/js/73.5a0eb88e.js"><link rel="prefetch" href="/assets/js/74.23636aea.js"><link rel="prefetch" href="/assets/js/75.50267214.js"><link rel="prefetch" href="/assets/js/76.56bf8931.js"><link rel="prefetch" href="/assets/js/77.50bf124e.js"><link rel="prefetch" href="/assets/js/78.16447a1c.js"><link rel="prefetch" href="/assets/js/79.04aa7ebf.js"><link rel="prefetch" href="/assets/js/8.87101dd9.js"><link rel="prefetch" href="/assets/js/80.5d01a188.js"><link rel="prefetch" href="/assets/js/81.f8607d18.js"><link rel="prefetch" href="/assets/js/82.34e8cb67.js"><link rel="prefetch" href="/assets/js/83.947a3b57.js"><link rel="prefetch" href="/assets/js/84.1c193059.js"><link rel="prefetch" href="/assets/js/85.8b1b503f.js"><link rel="prefetch" href="/assets/js/86.c530b306.js"><link rel="prefetch" href="/assets/js/87.06e6da51.js"><link rel="prefetch" href="/assets/js/88.10805f35.js"><link rel="prefetch" href="/assets/js/89.60cd520b.js"><link rel="prefetch" href="/assets/js/9.4e64f5b9.js"><link rel="prefetch" href="/assets/js/90.5d7e2d93.js"><link rel="prefetch" href="/assets/js/91.ddff81c9.js"><link rel="prefetch" href="/assets/js/92.d7928325.js"><link rel="prefetch" href="/assets/js/93.33fd0965.js"><link rel="prefetch" href="/assets/js/94.560df3d9.js"><link rel="prefetch" href="/assets/js/95.283a51cc.js"><link rel="prefetch" href="/assets/js/96.a8d91103.js"><link rel="prefetch" href="/assets/js/97.fe4a7179.js"><link rel="prefetch" href="/assets/js/98.064d454e.js"><link rel="prefetch" href="/assets/js/99.f6443506.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a748b10c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Zhoujc's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">
  前端相关
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node实践
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/ai/" class="nav-link">
  AI
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end/" class="nav-link router-link-active">
  前端相关
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node实践
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/ai/" class="nav-link">
  AI
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/front-end/" aria-current="page" class="sidebar-link">前端系列</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React深入系列</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end/react/hooks/optimize.html" class="sidebar-link">React函数式组件优化</a></li><li><a href="/front-end/react/hooks/" class="sidebar-link">React Hooks实现原理</a></li><li><a href="/front-end/react/lifecycle/" class="sidebar-link">React v16.4的生命周期理解</a></li><li><a href="/front-end/react/hoc/" class="sidebar-link">React高阶组件</a></li><li><a href="/front-end/react/redux/" class="sidebar-link">Redux实现原理</a></li><li><a href="/front-end/react/source/setState.html" class="sidebar-link">深入理解setState</a></li><li><a href="/front-end/react/source/fiber.html" aria-current="page" class="active sidebar-link">React任务调度</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#reconciler" class="sidebar-link">Reconciler</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#fibernode" class="sidebar-link">FiberNode</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#schedulerootupdate" class="sidebar-link">scheduleRootUpdate</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#schedulework" class="sidebar-link">scheduleWork</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#requestwork" class="sidebar-link">requestWork</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#completeroot" class="sidebar-link">completeRoot</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#createinstance" class="sidebar-link">createInstance</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/front-end/react/source/fiber.html#参考文章" class="sidebar-link">参考文章</a></li></ul></li><li><a href="/front-end/react/source/dom.html" class="sidebar-link">React组件的初始化与挂载</a></li><li><a href="/front-end/react/ssr/" class="sidebar-link">React服务端渲染</a></li><li><a href="/front-end/react/diff/" class="sidebar-link">React虚拟DOM和Diff算法</a></li><li><a href="/front-end/react/xss/" class="sidebar-link">React XSS注意事项</a></li><li><a href="/front-end/react/event/" class="sidebar-link">React的合成事件</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器和网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>移动端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>绘图</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react任务调度"><a href="#react任务调度" class="header-anchor">#</a> React任务调度</h1> <p>上篇分析了组件的初始化，原本想把挂载方式也一块解析下，发现这挂载嵌在了任务调度的最后一个环节，而这任务调度实属复杂，本篇就浅析一下这个任务调度。</p> <h2 id="reconciler"><a href="#reconciler" class="header-anchor">#</a> Reconciler</h2> <p>在16+的React版本 <a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noopener noreferrer">Fiber Reconciler（调和器）
<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 推出之前，React 用的是 <a href="https://reactjs.org/docs/implementation-notes.html" target="_blank" rel="noopener noreferrer">Stack Reconciler<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它是自顶向下递归渲染及更新的，持续占用主线程并且是无法中断的，主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，假如交互反馈延迟稍微大一丢丢，就会有明显的卡顿，这是影响体验的。</p> <p>而 Fiber 就是为了解决上面的问题而诞生的，它把渲染或者更新过程拆分成一系列小任务，做完看是否有时间继续下一个任务，有的话继续，没有则自己挂起，主线程优先做更高优先级的任务，待到主线程不忙的时候再继续不太紧急的任务。这一切的实现是在代码层引入了新的数据结构对象 Fiber ，每一个组件实例都对应一个fiber实例，fiber实例负责管理组件实例的更新，渲染以及与其他fiber实例的联系。</p> <p>初步了解 Fiber 的目的以后，我们回到上一章节的思维导图：</p> <p><img src="/assets/img/component-3.d1ed0251.png" alt=""></p> <p>首先我们去看下 Fiber 的数据结构，从 <code>createFiberRoot()</code> 切入，我们发现最终调用 <code>new FiberNode()</code> 创建了一个作用于组件的 Fiber 对象</p> <h2 id="fibernode"><a href="#fibernode" class="header-anchor">#</a> FiberNode</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 标记不同的组件类型</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>

  <span class="token comment">// ReactElement 里面的 key</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>

  <span class="token comment">// ReactElement.type，也就是我们调用`createElement`的第一个参数</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// fiber 对应的 function/class/module 类型组件名.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// fiber 所在组件树的根组件 FiberRoot 对象</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 处理完当前 fiber 后返回的 fiber，</span>
  <span class="token comment">// 返回当前 fiber 所在 fiber 树的父级 fiber 实例</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// fiber 树结构相关属性</span>
  <span class="token comment">// 指向自己的第一个子节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 指向自己的兄弟结构</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// ref属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 当前处理过程中的组件 props 对象</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>

  <span class="token comment">// 缓存上一次渲染完成之后的 props 对象</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 该组件状态更新及对应回调函数的存储队列</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 上一次渲染的时候的state</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 存放这个 fiber 依赖的 context</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>contextDependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 创建时候的标识，用来描述当前 fiber 和它子树的</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

  <span class="token comment">// Effects</span>
  <span class="token comment">// 用来记录Side Effect</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>

  <span class="token comment">// 单链表用来快速查找下一个side effect</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 子树中第一个side effect</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 子树中最后一个side effect</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 更新任务的最晚执行时间，注意不包括他的子树产生的任务</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> NoWork<span class="token punctuation">;</span>

  <span class="token comment">// 快速确定子树中是否有不在等待的变化</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>childExpirationTime <span class="token operator">=</span> NoWork<span class="token punctuation">;</span>

  <span class="token comment">// fiber的版本池，记录fiber更新过程，便于在发生冲突需要回退时快速恢复</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 调试相关，收集每个Fiber和子树渲染时间的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableProfilerTimer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>actualDuration <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token number">NaN</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>actualStartTime <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token number">NaN</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>selfBaseDuration <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token number">NaN</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>treeBaseDuration <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token number">NaN</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>actualDuration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>actualStartTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>selfBaseDuration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>treeBaseDuration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_debugID <span class="token operator">=</span> debugCounter<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_debugSource <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_debugOwner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_debugIsCurrentlyTiming <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_debugHookTypes <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasBadMapPolyfill <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Object<span class="token punctuation">.</span>preventExtensions <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>都说 Fiber 可以切分任务并设置不同优先级，它是如何做的又是怎样表现的？
从上面的数据结构是不是就可以看出来了？就是 <code>expirationTime</code> ，实现调度的方式正是<b>给每一个fiber实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行</b>。</p> <h2 id="schedulerootupdate"><a href="#schedulerootupdate" class="header-anchor">#</a> scheduleRootUpdate</h2> <p>下面我们接着看看任务调度那一块 <code>scheduleRootUpdate()</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">scheduleRootUpdate</span><span class="token punctuation">(</span><span class="token parameter">current$$<span class="token number">1</span><span class="token punctuation">,</span> element<span class="token punctuation">,</span> expirationTime<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token comment">// 创建一个更新用的初始化对象</span>
  <span class="token keyword">var</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span> element<span class="token operator">:</span> element <span class="token punctuation">}</span><span class="token punctuation">;</span>

  callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> callback<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 根据回调来判断是关闭还是跟踪状态</span>
  <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 记录当前fiber的版本，加入更新队列</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>current$$<span class="token number">1</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">scheduleWork</span><span class="token punctuation">(</span>current$$<span class="token number">1</span><span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> expirationTime<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="schedulework"><a href="#schedulework" class="header-anchor">#</a> scheduleWork</h2> <p><code>scheduleWork</code> 这一步非常重要，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">scheduleWork</span><span class="token punctuation">(</span><span class="token parameter">fiber<span class="token punctuation">,</span> expirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 找到当前 Fiber的 root</span>
  <span class="token keyword">var</span> root <span class="token operator">=</span> <span class="token function">scheduleWorkToRoot</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>

  <span class="token comment">// 如果不是工作状态，并且之前执行过任务，并且当前任务执行的时间比之前的执行的任务时间要大(就是优先级要低的意思)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isWorking <span class="token operator">&amp;&amp;</span> nextRenderExpirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span> expirationTime <span class="token operator">&gt;</span> nextRenderExpirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 中断任务</span>
    interruptedBy <span class="token operator">=</span> fiber<span class="token punctuation">;</span>
    <span class="token comment">// 重置所有公共变量</span>
    <span class="token function">resetStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 记录各项时间</span>
  <span class="token function">markPendingPriorityLevel</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 如果在渲染阶段，我们会在退出之前安排好更新，除非这是一个不同的根(应用程序有多个root)。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isWorking <span class="token operator">||</span> isCommitting$<span class="token number">1</span> <span class="token operator">||</span> nextRoot <span class="token operator">!==</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新过期时间</span>
    <span class="token keyword">var</span> rootExpirationTime <span class="token operator">=</span> root<span class="token punctuation">.</span>expirationTime<span class="token punctuation">;</span>
    <span class="token comment">// 开始处理任务</span>
    <span class="token function">requestWork</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> rootExpirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// nestedUpdateCount初始值为0，在commit阶段会检查是否这是一个嵌套的更新，如果下一个根之前是一模一样的根，它就是一个嵌套更新，为了防止无限循环就会进行自增，一旦达到50次（NESTED_UPDATE_LIMIT）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nestedUpdateCount <span class="token operator">&gt;</span> <span class="token constant">NESTED_UPDATE_LIMIT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 重置nestedUpdateCount变量，后续不更新</span>
    nestedUpdateCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">invariant</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="requestwork"><a href="#requestwork" class="header-anchor">#</a> requestWork</h2> <p>现在看下任务处理</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">requestWork</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> expirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  把 root 加入到调度队列，不会存在两个相同的 root 前后出现在队列中</span>
  <span class="token function">addRootToSchedule</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRendering<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 这里涉及到事件系统，后续再进行写作分析</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isBatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isUnbatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextFlushedRoot <span class="token operator">=</span> root<span class="token punctuation">;</span>
      nextFlushedExpirationTime <span class="token operator">=</span> Sync<span class="token punctuation">;</span>
      <span class="token function">performWorkOnRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> Sync<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 根据 expirationTime 来执行同步还是异步任务，最终都会调用 performSyncWork</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>expirationTime <span class="token operator">===</span> Sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performSyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">scheduleCallbackWithExpirationTime</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>仔细往里面看，会发现同步任务 <code>performSyncWork</code> 和异步任务<code>scheduleCallbackWithExpirationTime</code> 最终都会调用 <code>performSyncWork</code> 方法。</p> <p>同步异步的处理都在 <code>performWorkOnRoot</code> 里进行，如果有上次遗留的任务，会直接调用<code>completeRoot</code> 进到提交阶段。如果没有就调 <code>renderRoot</code>开始渲染阶段。
异步任务主要是渲染的时候判断一下时间，如果没时间了，先把 <code>finishedWork</code> 赋给全局，下次循环处理。</p> <h2 id="completeroot"><a href="#completeroot" class="header-anchor">#</a> completeRoot</h2> <p>我们先沿着提交阶段的线索 <code>completeRoot</code> 往下看</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">completeRoot</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> finishedWork<span class="token punctuation">,</span> expirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查是否有一批这个过期时间相匹配。</span>
  <span class="token keyword">var</span> firstBatch <span class="token operator">=</span> root<span class="token punctuation">.</span>firstBatch<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>firstBatch <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> firstBatch<span class="token punctuation">.</span>_expirationTime <span class="token operator">&gt;=</span> expirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedBatches <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      completedBatches <span class="token operator">=</span> <span class="token punctuation">[</span>firstBatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      completedBatches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>firstBatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstBatch<span class="token punctuation">.</span>_defer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 满足这个条件的这批根无法提交，直到收到新的更新</span>
      root<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>
      root<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> NoWork<span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 提交根.</span>
  root<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 检查是否这是一个嵌套的更新(同步更新计划中提交阶段)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> lastCommittedRootDuringThisBatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果下一根之前一样的根,这是一个嵌套的更新。为了防止无限循环,增加嵌套的更新计数。</span>
    nestedUpdateCount<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 重置根开关</span>
    lastCommittedRootDuringThisBatch <span class="token operator">=</span> root<span class="token punctuation">;</span>
    nestedUpdateCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">unstable_runWithPriority</span><span class="token punctuation">(</span>unstable_ImmediatePriority<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最终会更新 <code>expirationTime</code> 值和重置 <code>finishedWork</code> 为 <code>null</code>。</p> <p>而 <code>renderRoot</code> 则是开始渲染阶段了，里面有个 <code>workLoop</code> 循环机制不管是同步任务还是异步任务都要进行 <code>performUnitOfWork</code> 通过 <code>beginWork</code> 进行各项子节点的调和更新，直到完成工作进行 <code>createInstance</code>，创建 DOM 元素并添加至文档，最后通过 <code>onComplete</code> 更新 <code>root</code> 节点的 <code>pendingCommitExpirationTime</code> 为当前的过期时间 <code>expirationTime</code> 值和 <code>finishedWork</code> 的值。想要挖掘 <code>beginWork</code> 里的具体调和更新细节有兴趣的同学可以再钻研进去看看。</p> <h2 id="createinstance"><a href="#createinstance" class="header-anchor">#</a> createInstance</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">,</span> hostContext<span class="token punctuation">,</span> internalInstanceHandle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> parentNamespace <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>

  <span class="token comment">// 真实创建dom</span>
  <span class="token keyword">var</span> domElement <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">,</span> parentNamespace<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">precacheFiberNode</span><span class="token punctuation">(</span>internalInstanceHandle<span class="token punctuation">,</span> domElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">updateFiberProps</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> domElement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>precacheFiberNode</code> 个人认为是新建了一个 <code>new FiberNode()</code> 的实例，而<code>updateFiberProps</code> 方法是将真实 dom 和 fiber，props关联在一起了，互相引用。</p> <p>看到这里终于知道16+的 React 是在 createInstance 开始创建 dom 实例的，也就是之前所说的组件挂载就是在这里准备开始执行的。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><img src="/assets/img/react-20.a736b923.png" alt=""></p> <h2 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h2> <blockquote><p>https://react.jokcy.me/</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front-end/react/source/setState.html" class="prev">
        深入理解setState
      </a></span> <span class="next"><a href="/front-end/react/source/dom.html">
        React组件的初始化与挂载
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ebc66fdf.js" defer></script><script src="/assets/js/2.d4b9d712.js" defer></script><script src="/assets/js/27.4b69f932.js" defer></script>
  </body>
</html>
