(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{589:function(t,s,e){"use strict";e.r(s);var a=e(42),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"nodejs的错误处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs的错误处理"}},[t._v("#")]),t._v(" nodejs的错误处理")]),t._v(" "),e("blockquote",[e("p",[t._v("原文链接：https://zhuanlan.zhihu.com/p/100244941")])]),t._v(" "),e("h2",{attrs:{id:"capturestacktrace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#capturestacktrace"}},[t._v("#")]),t._v(" captureStackTrace")]),t._v(" "),e("p",[t._v("Node.js 中，"),e("code",[t._v("Error.captureStackTrace()")]),t._v(" 方法是 v8 引擎暴露出来的，处理错误堆栈信息的 API。")]),t._v(" "),e("blockquote",[e("p",[t._v("Error.captureStackTrace(targetObject[, constructorOpt]) 在 targetObject 中添加一个 .stack 属性。对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息(即：调用栈历史)。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'some error'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'some error...'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("错误并不能被捕获住。这个跟 "),e("code",[t._v("Node.js 的事件循环机制")]),t._v("有关，因为异步任务是通过事件队列来实现的，每次从事件队列中取出一个函数来执行时，实际上这个函数是在调用栈的最顶层执行的，如果它抛出了一个异常，也是无法沿着调用栈回溯到这个异步任务的创建者的。")]),t._v(" "),e("h2",{attrs:{id:"常见异步场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见异步场景"}},[t._v("#")]),t._v(" 常见异步场景")]),t._v(" "),e("ol",[e("li",[t._v("Node.js style callback")]),t._v(" "),e("li",[t._v("Promise")]),t._v(" "),e("li",[t._v("EventEmitter")])]),t._v(" "),e("p",[e("code",[t._v("Promise")]),t._v("链上的错误都会在"),e("code",[t._v("catch")]),t._v("方法上捕获住。对于没有"),e("code",[t._v("catch")]),t._v("的"),e("code",[t._v("Promise")]),t._v("异常，会一直冒泡到顶层，在"),e("code",[t._v("process.unhandledRejection")]),t._v("事件上被捕获住。\n实现"),e("code",[t._v("unhandledRejection")]),t._v("(V8 提供了接口（"),e("code",[t._v("SetPromiseRejectCallback")]),t._v("），当有未捕获的"),e("code",[t._v("Promise")]),t._v("错误时，会触发回调。Node.js 会在这个回调中记录下这些错误的"),e("code",[t._v("Promise")]),t._v("的信息；\nNode.js 会在每次"),e("code",[t._v("Tick")]),t._v("执行完后检查是否有未捕获的错误"),e("code",[t._v("Promise")]),t._v("，如果有，则触发 "),e("code",[t._v("unhandledRejection")]),t._v("事件。)")]),t._v(" "),e("p",[t._v("还有一类是 "),e("code",[t._v("EventEmitter")]),t._v(" 对象上的错误。它们会被分发到"),e("code",[t._v("error")]),t._v("事件上进行处理，比如"),e("code",[t._v("Stream")]),t._v("等。我们需要去为每一个流去监听"),e("code",[t._v("error")]),t._v("事件，否则会冒泡到"),e("code",[t._v("process.uncaughtException")]),t._v("事件上去。")]),t._v(" "),e("p",[t._v("异步场景中，还有个问题就是，会丢失异步回调前的错误堆栈。原因还是上文提到的 Node.js 事件循环机制。\n然而在 Node.js 中，异步调用场景还挺多的，有什么办法可以将多个异步调用给串起来，获取到完整的调用链信息呢？答案是有的。Node.js "),e("code",[t._v("v8+")]),t._v(" 上提供了 "),e("code",[t._v("async_hooks")]),t._v(" 模块，用来完善异步场景的监控。")])])}),[],!1,null,null,null);s.default=n.exports}}]);