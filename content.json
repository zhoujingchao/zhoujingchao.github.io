[{"title":"完全理解call()、apply()、bind()的用法和实现","date":"2019-08-26T02:16:13.000Z","path":"2019/08/26/完全理解call()、apply()、bind()的用法和实现/","text":"首先我们都知道这三兄弟都是为了改变函数运行时上下文(this指向)而存在的。 那么到底是个怎么回事呢，我们直接看下面得例子，来体验下： 123456789101112131415const name = 'Kobe', age = 18;const player = &#123; name: 'Irving', age: this.age, func: function() &#123; console.log(`$&#123;this.name&#125; is $&#123;this.age&#125; years old`) &#125;&#125;function getName() &#123; console.log(this.name)&#125;player.age // this 指向 player -&gt; 18player.func() // this 指向 player -&gt; Irving is 18 years oldgetName() // this 指向 window -&gt; Kobe 下面我们来看看三兄弟的用法 12345678910111213141516const name = 'Kobe', age = 18;const player = &#123; name: 'Irving', age: this.age || 16, func: function() &#123; console.log(`$&#123;this.name&#125; is $&#123;this.age&#125; years old`) &#125;&#125;const otherPlayer = &#123; name: 'Wade', age: 17&#125;player.func.call(otherPlayer) // Wade is 17 years oldplayer.func.apply(otherPlayer) // Wade is 17 years oldplayer.func.bind(otherPlayer)() // Wade is 17 years old 这里我们可以看出，一个参数的情况下，call和apply返回了相同的结果，bind呢则是返回了一个新的函数，你要执行它在返回结果。 接着看下多个参数的情况： 1234567891011121314151617const name = 'Kobe', age = 18;const player = &#123; name: 'Irving', age: this.age || 16, func: function(from, team) &#123; console.log(`$&#123;this.name&#125; is $&#123;this.age&#125; years old, from $&#123;from&#125;, play in the $&#123;team&#125;`) &#125;&#125;const otherPlayer = &#123; name: 'Wade', age: 17&#125;player.func.call(otherPlayer, 'Chicago', 'Heat') // Wade is 17 years old, from Chicago, play in the Heatplayer.func.apply(otherPlayer, ['Chicago', 'Heat']) // Wade is 17 years old, from Chicago, play in the Heatplayer.func.bind(otherPlayer, 'Chicago', 'Heat')() // Wade is 17 years old, from Chicago, play in the Heatplayer.func.bind(otherPlayer, ['Chicago', 'Heat'])() // Wade is 17 years old, from Chicago,Heat, play in undefined 我们又发现 call 是一个一个参数来接收的，apply 则是接受了一个列表，bind 则是除了返回函数以外，其他参数和 call 一样。所以看自己的应用场景来取择即可，你想要着重展现参数的意义就可以选 call，当然参数不仅仅是例子上的 string 类型，其他均可以。 看到这里是不是对这三兄弟是咋玩的有了一定的了解啦，接下去我们就去自己模拟实现它们，从而对他们加深理解。 模拟实现 call 12345678910111213Function.prototype._call = function(context = window) &#123; // 假如没传上下文 context 默认取 window if (this === Function.prototype) return; // 用于防止 Function.prototype._call() 直接调用 // 新建一个不会重名的属性，防止重写 const attr = Symbol() context[attr] = this // 把类数组变为数组，过滤 window 参数 const args = [...arguments].slice(1) const result = context[attr](args) delete context[attr] return result&#125; 模拟实现 apply 123456789101112131415Function.prototype._apply = function(context = window) &#123; if (this === Function.prototype) return; const attr = Symbol() context[attr] = this // 取出参数列表 const args = [...arguments][1] let result; if (!args) &#123; result = context[attr]() &#125; else &#123; result = context[attr](...args) &#125; delete context[attr] return result&#125; 模拟实现 bind 12345678Function.prototype._bind = function(context = window) &#123; const self = this const args = [...arguments].slice(1) return function() &#123; const newArg = [...arguments] return self.apply(context, args.concat(newArg)) &#125;&#125; 这下是不是完全理解这三兄弟了呢，他们就是为了改变函数运行时上下文而来的，根据实际情况来选择使用即可。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"React源码解析-组件的初始化与挂载（一）","date":"2019-08-19T08:03:14.000Z","path":"2019/08/19/React源码解析-组件的实现与挂载（一）/","text":"React 是笔者的主要技术栈之一，难免想探索一下内部的一些机制实现，笔者会从组件的初始化与挂载、任务调度、组件类型和生命周期、事务、事件、hook等方向进行学习解析，也是第一次进行源码解析的写作，如有欠妥之处，欢迎朋友们不吝指正和讨论，共同学习进步。 下面，我们先来看看 React 组件的实现 一、组件是什么首先编写一个最简单的组件 12345678910111213import React, &#123; Component &#125; from 'react';class App extends Component &#123; render() &#123; return ( &lt;div&gt;This is Component App&lt;/div&gt; ); &#125;&#125;console.log(&lt;App /&gt;)export default App; 这段代码我们实现了 &lt;App /&gt; 组件，我们打印出来看看是个啥： 可以看出，&lt;App /&gt; 其实是js对象不是真实的DOM，注意此时的 props 是空对象，接下来我们打印 &lt;App&gt;&lt;div&gt;This is Component App&lt;/div&gt;&lt;/App&gt;: 我们看到，props 发生了变化，由于 &lt;App /&gt; 组件中嵌套了一个 div，div 中又嵌套了文字，所以在描述 &lt;App /&gt; 对象的 props 中增加了 children 属性，其值为描述 div 的js对象。同理，如果我们进行多层的组件嵌套，其实就是在父对象的 props 中增加 children 字段及对应的描述值，也就是js对象的多层嵌套。 那么展现在我们眼前的html标签，实际上却是对象的React组件是如何实现的呢？ 我们从代码的组件声明为源头进行探索，所以我们打开react内umd规范下的 react.development.js，看到如下代码： 12345678910111213141516var React = &#123; Children: &#123; map: mapChildren, forEach: forEachChildren, count: countChildren, toArray: toArray, only: onlyChild &#125;, createRef: createRef, Component: Component, PureComponent: PureComponent, // ...&#125; 我们在 import React, { Component } from &#39;react&#39; 时，引入的就是源码中提供的 React 对象。在 extends Component 时，继承了 Component 类。因为 Component 是 React.Component 的引用。也就是说 Component === React.Component，在实际项目中都可以写。 沿着 Component 线索我们继续在这个文件里搜寻一下它的踪迹： 12345678910111213function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;Component.prototype.isReactComponent = &#123;&#125;;Component.prototype.setState = function (partialState, callback) &#123; // ...&#125;;Component.prototype.forceUpdate = function (callback) &#123; // ...&#125;; 上述代码大家再熟悉不过了。同时我们也发现 setState 是定义在原型上具有两个参数的方法，具体原理我们将在后续的篇章进行解析。 上述代码表明，我们在最开始声明的组件App，其实是继承 Component类，它的原型具有 setState 等方法。这样组件App已经有了最基本的雏形。 二、组件的初始化声明App后，我们可以在其内部自定义方法，也可以使用生命周期的方法，这些和我们在写”类”的时候是完全一样的。唯一不同的是组件类必须拥有 render 方法输出类似 &lt;div&gt;This is Component App&lt;/div&gt;的结构并挂载到真实DOM上，才能触发组件的生命周期并成为DOM树的一部分。首先我们观察ES6的”类”是如何初始化一个react组件的。 将最初的代码放入 babel 中123456789101112131415161718192021var App =function (_Component) &#123; _inherits(App, _Component); function App() &#123; _classCallCheck(this, App); return _possibleConstructorReturn(this, _getPrototypeOf(App).apply(this, arguments)); &#125; _createClass(App, [&#123; key: \"render\", value: function render() &#123; return _react.default.createElement(\"div\", null, \"This is Component App\"); &#125; &#125;]); return App;&#125;(_react.Component);exports.default = App; 其中 _Component 是对象 Component，_inherit 方法是 extends 关键字的函数实现，这些都是ES6相关内容，我们暂时不管。关键在于我们发现 render 方法实际上是调用了 _react.default.createElement 方法。然后我们继续在我们的源码文件中搜寻 createElement： 1234567891011121314function createElement(type, config, children) &#123; var propName = void 0; var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; // ... return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);&#125; 接着搜寻 ReactElement: 12345678910111213141516var ReactElement = function (type, key, ref, self, source, owner, props) &#123; var element = &#123; $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, _owner: owner &#125;; // ... return element;&#125;; 看到这里我们发现，每一个组件对象都是通过 ReactElement 方法创建出来的对象。换句话说，ReactElment 是一种内部记录组件特征的对象。在 ReactElement 中: $$typeof: 使用符号标记每个ReactElement type: 用于判断如何创建节点 key: DOM结构标识，提升update性能 ref: 真实DOM的 props: 子结构相关信息(有则增加children字段/没有为空)和组件属性(如style等等) _owner: _owner === ReactCurrentOwner.current, 值为创建当前组件的对象，默认值为null 总的来说，ReactElement 就是一个用来承载信息的容器，对于后期构建应用的树结构是非常重要的。 二、组件的挂载我们知道可以通过 ReactDOM.render(component, mountNode)的形式对自定义组件/原生DOM/字符串进行挂载。 我们看下源码实现，找到react-dom内umd规范下的 react-dom.development.js，找到 render 方法看一下： 1234render: function (element, container, callback) &#123; // ... return legacyRenderSubtreeIntoContainer(null, element, container, false, callback); &#125; 1234567891011121314151617181920212223242526272829303132333435363738function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) &#123; // ... var root = container._reactRootContainer; if (!root) &#123; // Initial mount root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate); if (typeof callback === 'function') &#123; var originalCallback = callback; callback = function () &#123; var instance = getPublicRootInstance(root._internalRoot); originalCallback.call(instance); &#125;; &#125; // Initial mount should not be batched. unbatchedUpdates(function () &#123; if (parentComponent != null) &#123; root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback); &#125; else &#123; root.render(children, callback); &#125; &#125;); &#125; else &#123; if (typeof callback === 'function') &#123; var _originalCallback = callback; callback = function () &#123; var instance = getPublicRootInstance(root._internalRoot); _originalCallback.call(instance); &#125;; &#125; // Update if (parentComponent != null) &#123; root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback); &#125; else &#123; root.render(children, callback); &#125; &#125; return getPublicRootInstance(root._internalRoot);&#125; 因为是首次渲染更新，所以 root 是 null，只需看 !root 的情况，它调用了 legacyCreateRootFromDOMContainer，我们接着往下看： 1234567891011121314151617181920212223242526function legacyCreateRootFromDOMContainer(container, forceHydrate) &#123; var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content. if (!shouldHydrate) &#123; var warned = false; var rootSibling = void 0; while (rootSibling = container.lastChild) &#123; &#123; if (!warned &amp;&amp; rootSibling.nodeType === ELEMENT_NODE &amp;&amp; rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) &#123; warned = true; warningWithoutStack$1(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.'); &#125; &#125; container.removeChild(rootSibling); &#125; &#125; &#123; if (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123; warnedAboutHydrateAPI = true; lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.'); &#125; &#125; // Legacy roots are not async by default. var isConcurrent = false; return new ReactRoot(container, isConcurrent, shouldHydrate);&#125; 此时 forceHydrate 是 false，所以看 shouldHydrateDueToLegacyHeuristic(container) 返回的是啥？ 123456789// 判断是否为服务端渲染function shouldHydrateDueToLegacyHeuristic(container) &#123; //获取container的第一个节点（根节点），也就是 id='root' 的节点 var rootElement = getReactRootElementInContainer(container); return !!(rootElement &amp;&amp; rootElement.nodeType === ELEMENT_NODE &amp;&amp; // 判断是否是服务端渲染 rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));&#125; 1var ROOT_ATTRIBUTE_NAME = 'data-reactroot'; 1234567891011function getReactRootElementInContainer(container) &#123; if (!container) &#123; return null; &#125; if (container.nodeType === DOCUMENT_NODE) &#123; return container.documentElement; &#125; else &#123; return container.firstChild; &#125;&#125; container 的首节点是没有 data-reactroot 属性的，所以会进行while循环，依次删除 container 的子节点，删除完毕后，new 一个 ReactRoot 的实例。所以说判断是否是服务端渲染的标志是：在获取 container 中的第一个节点（或文档节点）后，看该节点是否有属性 ROOT_ATTRIBUTE_NAME。 接着 ReactRoot 的线索往下看，通过 createContainer 去创建 FiberRoot, 这个 FiberRoot 对象在后期调度更新的过程中非常非常重要，也是新版React的核心。 1234function ReactRoot(container, isConcurrent, hydrate) &#123; var root = createContainer(container, isConcurrent, hydrate); this._internalRoot = root;&#125; 123function createContainer(containerInfo, isConcurrent, hydrate) &#123; return createFiberRoot(containerInfo, isConcurrent, hydrate);&#125; 12345678910111213ReactRoot.prototype.render = function (children, callback) &#123; var root = this._internalRoot; var work = new ReactWork(); callback = callback === undefined ? null : callback; &#123; warnOnInvalidCallback(callback, 'render'); &#125; if (callback !== null) &#123; work.then(callback); &#125; updateContainer(children, root, null, work._onCommit); return work;&#125;; 12345678910function updateContainer(element, container, parentComponent, callback) &#123; var current$$1 = container.current; // 返回的时间是以下这种数据类型 // 是以V8引擎上最大31位整数1073741823为根据的 // 可以追溯这个requestCurrentTime函数，就能看见源码注释了 var currentTime = requestCurrentTime(); // 计算过期时间，这是React优先级更新非常重要的点 var expirationTime = computeExpirationForFiber(currentTime, current$$1); return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);&#125; 我们发现调用了 updateContainer 方法后，内部开始计算时间 requestCurrentTime(), computeExpirationForFiber()暂且先不管具体细节。 12345function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) &#123; var current$$1 = container.current; // ... return scheduleRootUpdate(current$$1, element, expirationTime, callback);&#125; 1234567891011121314151617181920212223242526272829function scheduleRootUpdate(current$$1, element, expirationTime, callback) &#123; &#123; if (phase === 'render' &amp;&amp; current !== null &amp;&amp; !didWarnAboutNestedUpdates) &#123; didWarnAboutNestedUpdates = true; warningWithoutStack$1(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown'); &#125; &#125; // 创建更新的时间节点 var update = createUpdate(expirationTime); // Caution: React DevTools currently depends on this property // being called \"element\". update.payload = &#123; element: element &#125;; callback = callback === undefined ? null : callback; if (callback !== null) &#123; !(typeof callback === 'function') ? warningWithoutStack$1(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0; update.callback = callback; &#125; flushPassiveEffects(); // 整个React应用中，会有多次更新，而这多次更新都在这个更新队列中 enqueueUpdate(current$$1, update); // 进行任务调度，当React进行Update后，就要进行调度 // 即根据任务的优先级去调度任务，先执行优先级高的任务， scheduleWork(current$$1, expirationTime); return expirationTime;&#125; enqueueUpdate() 和 scheduleWork()，这个任务调度是最重要且最复杂的内容了，后续慢慢来解析。以上我们看见这个计划更新root的函数最终返回了一个 expirationTime, 就是说 updateContainer() 返回了 expirationTime。 到这先告一段落了，我们接着回到 legacyRenderSubtreeIntoContainer 函数往下看最终返回了 getPublicRootInstance： 123456789101112function getPublicRootInstance(container) &#123; var containerFiber = container.current; if (!containerFiber.child) &#123; return null; &#125; switch (containerFiber.child.tag) &#123; case HostComponent: return getPublicInstance(containerFiber.child.stateNode); default: return containerFiber.child.stateNode; &#125;&#125; React初始化的时候，container.current 是没有子节点的，所以返回 null。 最后我们对之前的思维图再进行补充： 已经有点长了，暂时先解析到这里。组件是如何挂载到真正的DOM上以及它的任务调度又是如何，笔者在下一篇再来解析。","tags":[{"name":"react","slug":"react","permalink":"//zhoujingchao.github.io/tags/react/"}]},{"title":"egg-rocketmq消息中间件","date":"2019-08-13T03:52:15.000Z","path":"2019/08/13/egg-rocketmq消息中间件/","text":"前一阵子的业务驱使下，出于考虑系统稳定性以及 java 和 node 的解耦性，node端接入了中台已有的 rocketmq 消息中间件，我们 node 业务架子用的是 egg，在这基础上结合中台和相关业务，做过二次框架开发。这回接入 rocketmq 使得编码方式一点都不友好，所有的生产者和消费者业务代码统统不符合 egg 本身编码规范。因此后面利用碎片化时间，撸了一个 egg-rocketmq 插件，是基于 rocketmq-client-nodejs 扩展的，有需要的或者感兴趣的同学可以试一试。","tags":[{"name":"eggjs","slug":"eggjs","permalink":"//zhoujingchao.github.io/tags/eggjs/"}]},{"title":"puppeteer实战系列-网页性能分析（三）","date":"2019-07-14T08:53:18.000Z","path":"2019/07/14/puppeteer实战系列-网页性能分析（三）/","text":"前两篇文章中，我们讲了安装和截图，这篇我们来讲讲页面性能分析的相关体系。 众所周知，页面性能优化要讲起来可谓是整大条链路上的事情，在这里笔者将不开展描述，后续笔者会出个全面的性能优化系列文章再进行讲解。回到我们的正题，我们是利用 puppeteer 对页面进行性能数据采集并分析，达到一个性能监控的效果。 这里笔者是用的 Web performance 收集的，毕竟是原生对吧。 GoogleChrome 推的 lighthouse 也是个不错的工具，感兴趣的同学可自行研究 传送门 当然了，咱们要分析的页面在这里不是咱自家产的，假如是自家页面，那我们只需要将代码包装成sdk，用户访问的时候收集真实数据，再分析即可。所以这里主要是模拟分析第三方的页面。在讲具体操作前，我们先来认识一下 performance，看下图 相关时间点在 timing 里，加载的资源列表在 getEntries 里，笔者也是根据下面这张图来归结相关时间节点数据的，有不对的地方同学们帮忙指正下 所以有了下面核心代码 1234567891011121314151617181920212223242526272829function performance() &#123; const data = &#123; cache: ['domainLookupStart', 'fetchStart'], // 读取缓存时间 dns: ['domainLookupEnd', 'domainLookupStart'], // DNS 解析耗时 tcp: ['connectEnd', 'connectStart'], // TCP 连接耗时 req: ['responseStart', 'requestStart'], // 网络请求耗时 res: ['responseEnd', 'responseStart'], // 数据传输耗时 dom: ['domContentLoadedEventStart', 'domLoading'], // DOM 解析耗时 readycb: ['domContentLoadedEventEnd', 'domContentLoadedEventStart'], // domContentLoaded回调函数耗时 fasrt: ['domComplete', 'domContentLoadedEventEnd'], // 首屏异步资源加载耗时，即domContentLoaded和load之间加载的资源，一般为图片加载，JS异步加载的资源 loadcb: ['loadEventEnd', 'loadEventStart'], // load回调函数耗时 ready: ['domContentLoadedEventEnd', 'fetchStart'], // DOM Ready耗时，白屏时间 load: ['loadEventEnd', 'fetchStart'] // 页面完全加载时间 &#125;; const getData = &#123;&#125;; const performance = window.performance || window.msPerformance || window.webkitPerformance; if (!performance || !performance.timing) &#123; return null; &#125; const timing = performance.timing; Object.keys(data).map(item =&gt; &#123; const firstParams = timing[data[item][0]]; const secondParams = timing[data[item][1]]; const value = Math.round(firstParams - secondParams); value &gt;= 0 &amp;&amp; value &lt; 36e5 &amp;&amp; (getData[item] = value); &#125;); getData.resourceList = performance.getEntries(); return getData;&#125; 所以当我们加载第三方页面的时候，我们插入此脚本，把数据捞出来，下面举个🌰 12345678910111213141516171819202122232425262728const browser = await puppeteer.launch(&#123; headless: true, args: [ '--no-sandbox', '--disable-setuid-sandbox' ],&#125;);const page = await browser.newPage();await page.goto('https://juejin.im', &#123; waitUntil: [ 'load' ]&#125;);const monitorData = await page.evaluate(() =&gt; &#123; // 这里就拿我们最常见也最关心的数据，更全的看上面核心代码图即可 const data = &#123; ready: [ 'domContentLoadedEventEnd', 'fetchStart' ], // DOM Ready耗时，白屏时间 load: [ 'loadEventEnd', 'fetchStart' ] // 页面完全加载时间 &#125;; const getData = &#123;&#125;; const performance = window.performance || window.msPerformance || window.webkitPerformance; const timing = performance.timing; Object.keys(data).map(item =&gt; &#123; const firstParams = timing[data[item][0]]; const secondParams = timing[data[item][1]]; const value = Math.round(firstParams - secondParams); value &gt;= 0 &amp;&amp; value &lt; 36e5 &amp;&amp; (getData[item] = value); &#125;); getData.resourceList = performance.getEntries(); return Promise.resolve(getData);&#125;);console.log(monitorData); 拿到这些数据后，就可以开展各自的业务的场景了，比如后台系统上的展示监控，钉钉报警优化等等。再复杂一点的场景可能需要模拟网络环境，我们需要再添加一些代码，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const NETWORK_PRESETS = &#123; // 所有速度 / 8 是因为网络速度通常以比特/秒,而 DevTools 预计吞吐量在字节/秒! （1字节 = 8比特） GPRS: &#123; offline: false, // 是否连接 downloadThroughput: (50 * 1024) / 8, // 模拟下载速度 uploadThroughput: (20 * 1024) / 8, // 模拟上传速度 latency: 500 // 模拟延迟（毫秒） &#125;, Regular2G: &#123; offline: false, downloadThroughput: (250 * 1024) / 8, uploadThroughput: (50 * 1024) / 8, latency: 300 &#125;, Good2G: &#123; offline: false, downloadThroughput: (450 * 1024) / 8, uploadThroughput: (150 * 1024) / 8, latency: 150 &#125;, Regular3G: &#123; offline: false, downloadThroughput: (750 * 1024) / 8, uploadThroughput: (250 * 1024) / 8, latency: 100 &#125;, Good3G: &#123; offline: false, downloadThroughput: (1.5 * 1024 * 1024) / 8, uploadThroughput: (750 * 1024) / 8, latency: 40 &#125;, Regular4G: &#123; offline: false, downloadThroughput: (4 * 1024 * 1024) / 8, uploadThroughput: (3 * 1024 * 1024) / 8, latency: 20 &#125;, DSL: &#123; offline: false, downloadThroughput: (2 * 1024 * 1024) / 8, uploadThroughput: (1 * 1024 * 1024) / 8, latency: 5 &#125;, WiFi: &#123; offline: false, downloadThroughput: (30 * 1024 * 1024) / 8, uploadThroughput: (15 * 1024 * 1024) / 8, latency: 2 &#125;&#125;;async function start(url, network) &#123; const browser = await puppeteer.launch(&#123; headless: true, args: [ '--no-sandbox', '--disable-setuid-sandbox' ], &#125;); const page = await browser.newPage(); await page.goto(url, &#123; waitUntil: [ 'load' ]&#125;); // 添加网络环境 if (network !== 'default') &#123; // Connect to Chrome DevTools const client = await page.target().createCDPSession(); // Set throttling property await client.send('Network.emulateNetworkConditions', NETWORK_PRESETS[network]); &#125; const monitorData = await page.evaluate(() =&gt; &#123; // ...同上 &#125;); console.log(monitorData);&#125; 总结window.performance.getEntries() 的方式拿到的资源，不是本域下面的话，一般是拿不到资源大小的，这个是由第三方cdn或者服务器所控制的。lighthouse 是拿得到的，所以根据各自场景，结合起来使用也是没问题的。另外 puppeteer 本身也提供一些页面数据在 page.metrics() 方法里，同学们可自行查看。","tags":[{"name":"puppeteer","slug":"puppeteer","permalink":"//zhoujingchao.github.io/tags/puppeteer/"}]},{"title":"puppeteer实战系列-截图的诱惑（二）","date":"2019-07-12T09:37:51.000Z","path":"2019/07/12/puppeteer实战系列-截图的诱惑（二）/","text":"前面一篇文章讲了 puppeteer 的前期开展工作，这篇我们来讲下截图操作 官方入门 demo 12345678const puppeteer = require(\"puppeteer\");(async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(\"http://www.baidu.com\"); await page.screenshot(&#123; path: \"baidu.png\" &#125;); await browser.close();&#125;)(); 业务场景一、截全屏图1234567891011121314151617181920212223242526272829const puppeteer = require(\"puppeteer\");(async () =&gt; &#123; const options = &#123; headless: true, timeout: 0, args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"], ignoreHTTPSErrors: true &#125;; const browser = await puppeteer.launch(options); const page = await browser.newPage(); await page.goto(\"http://www.baidu.com\", &#123; waitUntil: [\"networkidle2\"], // https://pptr.dev/#?product=Puppeteer&amp;version=v1.18.1&amp;show=api-pagegotourl-options timeout: 20 * 1000 &#125;); // 如果 waitUntil 为'networkidle2'的方式还是会出现不能完全加载异步的内容 // 可以手动添加滑动操作以及延时等待去处理 await page.evaluate(() =&gt; &#123; return Promise.resolve(window.scrollTo(0, window.innerHeight)); &#125;); // await page.waitFor(2000); await page.screenshot(&#123; path: \"baidu.png\", fullPage: true &#125;); await browser.close();&#125;)(); 二、元素精确截图或者指定范围尺寸截图1234567891011121314151617181920212223242526272829303132333435363738394041const puppeteer = require(\"puppeteer\");(async () =&gt; &#123; async function getElementBounding(page, element) &#123; const pos = await page.$eval(element, e =&gt; &#123; // 相当于在evaluate的pageFunction内执行 // document.querySelector(element).getBoundingClientRect() // https://pptr.dev/#?product=Puppeteer&amp;version=v1.18.1&amp;show=api-pageevalselector-pagefunction-args-1 const &#123; left, top, width, height &#125; = e.getBoundingClientRect(); return &#123; left, top, width, height &#125;; &#125;); return pos; &#125; const options = &#123; headless: true, timeout: 0, args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"], ignoreHTTPSErrors: true &#125;; const browser = await puppeteer.launch(options); const page = await browser.newPage(); await page.goto(\"http://www.baidu.com\", &#123; waitUntil: [\"networkidle2\"], timeout: 20 * 1000 &#125;); await page.evaluate(() =&gt; &#123; return Promise.resolve(window.scrollTo(0, window.innerHeight)); &#125;); const pos = await getElementBounding(page, \".head_wrapper\"); await page.screenshot(&#123; path: \"baidu.png\", // 根据业务应用场景灵活运用 clip: &#123; x: pos.left, y: pos.top, width: pos.width, height: pos.height &#125; &#125;); await browser.close();&#125;)(); 性能优化业务复杂且量大的情况下，一般都是几百个或者上千个页面需要处理。我们通常都是 Promise.all() 并行处理异步，进行批量截图，但标签页一多，就会导致机器性能急剧下降。 于是我们可以把打开浏览器的个数和每个浏览器的标签页数都抽出来，可灵活调整，便于不同配置的机器在执行任务的时候方便调整，避免机器崩掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * startBrowser 启动浏览器 * @param &#123;array&#125; urlList 数据源 * @param &#123;number&#125; browserNum 打开的浏览器个数 * @param &#123;number&#125; tabNum 每个浏览器打开的标签页 * @return &#123;array&#125; */ async startBrowser(urlList, browserNum, tabNum) &#123; // 单个浏览器执行流程 const action = async (startPosition, length) =&gt; &#123; const options = &#123; headless: true, timeout: 0, args: [ '--no-sandbox', '--disable-setuid-sandbox' ], ignoreHTTPSErrors: true &#125;; const platform = os.platform().toLocaleLowerCase(); if (platform === 'linux') &#123; // 环境上chromium对应的安装路径 options.executablePath = path.join(__dirname, '../../../chrome-linux/chrome'); &#125; const browser = await puppeteer.launch(options); // 处理数据源 urlList const promises = []; for (let i = 0; i &lt; length; i++) &#123; const groupIndex = parseInt(i / tabNum, 10); promises[groupIndex] = promises[groupIndex] ? promises[groupIndex] : []; promises[parseInt(i / tabNum, 10)].push(urlList[i + startPosition]); &#125; const pagesGroups = []; for (let i = 0; i &lt; promises.length; i++) &#123; pagesGroups.push( await Promise.all( promises[i].map(async option =&gt; &#123; // 这里就不拿出来说了，单个标签页的执行截图逻辑，根据各自业务场景处理后，并返回数据即可 return await this.startPage(browser, option); &#125;) ) ); &#125; // 处理回调数据 const pages = []; pagesGroups.map(pagesGroup =&gt; &#123; pagesGroup.map(page =&gt; &#123; pages.push(page); &#125;); &#125;); await browser.close(); return pages; &#125;; // 根据打开的浏览器个数，拆分需要截图的数据 const result = [], promiseArr = []; for (let i = 0, len = urlList.length; i &lt; browserNum; i++) &#123; let SingleLen = parseInt(len / browserNum, 0); const startPosition = SingleLen * i; if (i === browserNum - 1) &#123; SingleLen = len - SingleLen * i; &#125; promiseArr.push(action(startPosition, SingleLen)); &#125; const allList = await Promise.all(promiseArr); allList.map(item =&gt; &#123; item.map(subItem =&gt; &#123; result.push(subItem); &#125;); &#125;); return result; &#125; 其次是通过 cluster 优化 puppeteer，多开一核，任务处理效率就会多翻一倍你可以通过自己编写 cluster.js 去处理，举个例子：12345678910111213141516171819202122const cluster = require('cluster');const startBrowser = require('./startBrowser');const numCPUs = require('os').cpus().length;const urls = require('./testData.js');(async () =&gt; &#123; if (cluster.isMaster) &#123; for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; &#125; else &#123; // 拆分每核要跑的业务数据 let len = parseInt(urls.length / numCPUs, 0) let start = len * (cluster.worker.id - 1); if (cluster.worker.id === numCPUs) &#123; len = urls.length - len * (numCPUs - 1); &#125; await startBrowser(urls, start, len); cluster.worker.kill(); &#125;&#125;)(); 也可以通过 pm2 来管理 node 进程，就省去了自己编写 cluster.js 的逻辑 1234567891011121314151617// http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/&#123; \"apps\": [ &#123; \"name\": \"screenshot-demo\", \"script\": \"./index.js\", // 入口文件 \"env\": &#123; \"NODE_ENV\": \"production\" &#125;, \"error_file\": \"./logs/app-err.log\", \"out_file\": \"./logs/app-out.log\", \"log_date_format\": \"YYYY-MM-DD HH:mm Z\", \"instances\" : 4, // 启动[数量]进程自动进行负载均衡。提高整体性能和性能稳定性 \"exec_mode\" : \"cluster\" &#125;]&#125; 启动方式1pm2 start pm2.json","tags":[{"name":"puppeteer","slug":"puppeteer","permalink":"//zhoujingchao.github.io/tags/puppeteer/"}]},{"title":"puppeteer实战系列-介绍及安装（一）","date":"2019-07-12T05:27:11.000Z","path":"2019/07/12/puppeteer实战系列-介绍及安装（一）/","text":"前言Puppeteer 是一个 Node 库，它提供了一个高级API来控制DevTools协议上的Chrome或Chromium。 Puppeteer默认运行无头，但可以配置为运行完整（非无头）Chrome或Chromium 用处可以在浏览器中手动执行的大多数事情都可以使用 Puppeteer 完成！以下是一些可以入门的示例： 生成页面的屏幕截图和PDF 爬取SPA应用，并生成预渲染内容（即 SSR 服务端渲染） 自动化表单提交，UI测试，键盘输入等 创建最新的自动化测试环境。使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中运行测试 捕获网站的时间线跟踪，以帮助诊断性能问题 测试Chrome扩展程序 安装及部署 本地 MacOS ：1yarn add puppeteer down不下来就试试换源，推荐 nrm 工具1yarn global add nrm 1nrm use taobao Centos 7 ：需要安装以下依赖，确保任务可以正常执行，相关字体依赖是解决截图后中文乱码问题的。（更多运行上的问题也可以查看此链接）1yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc 再设置123const browser = await puppeteer.launch(&#123; args: [ '--no-sandbox', '--disable-setuid-sandbox' ]&#125;) Docker : 官方推荐使用args参数：–disable-dev-shm-usage默认情况下，Docker运行一个/dev/shm共享内存空间为64MB 的容器。这通常对Chrome来说太小，并且会导致Chrome在渲染大页面时崩溃。要修复，必须运行容器 docker run –shm-size=1gb 以增加/dev/shm的容量。从Chrome 65开始，使用–disable-dev-shm-usage标志启动浏览器即可，这将会写入共享内存文件/tmp而不是/dev/shm 注⚠️：在某些情况下（例如在Docker中）很难正确终止Chrome。如果你遇到很多僵尸Chrome进程，那么 dumb-init 值得一试。对于PID = 1的进程有特殊处理， 最后如果还是down不下来puppeteer，那么请戳这里下载Chromium，放入对应的环境或者项目里。再设置 .npmrc 跳过下载 Chromium1puppeteer_skip_chromium_download = true 再启动浏览器123456789101112131415const options = &#123; headless: true, timeout: 0, args: [ '--no-sandbox', '--disable-setuid-sandbox' ], ignoreHTTPSErrors: true&#125;;const platform = os.platform().toLocaleLowerCase();// 你所存放的路径if (platform === 'linux') &#123; options.executablePath = path.join(__dirname, '../../../chrome-linux/chrome');&#125;const browser = await puppeteer.launch(options); Have fun ！","tags":[{"name":"puppeteer","slug":"puppeteer","permalink":"//zhoujingchao.github.io/tags/puppeteer/"}]},{"title":"JS常用设计模式详解[es5与es6]-工厂模式（二）","date":"2018-12-17T08:27:26.000Z","path":"2018/12/17/JS常用设计模式详解-es5与es6-工厂模式（二）/","text":"什么是工厂模式？工厂模式是用来创建对象的一种最常用的设计模式，我们不暴露创建对象的具体逻辑，而是提供一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类，而子类可以重写接口方法以便创建的时候指定自己的对象类型。所以这个创建对象的接口函数就可以视为一个工厂。工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 下面，我们先以一个场景去简单的理解下抽象和工厂的概念 想象一下你的女朋友生日要到了，你想知道她想要什么礼物，于是你问他：“亲爱哒，生日要到了呢，你想要什么生日礼物咩？” 于是她回答你说：“亲爱的，我想要一只动物。” 你心平气和（黑人问号？？？）的问她：“想要什么动物啊？” 你女友说：“我想要猫科动物。” 这时你内心就纳闷了，猫科动物有老虎，狮子，豹子，还有各种小猫，我哪里知道你要什么？ 于是你接着问女友：“你要哪种猫科动物啊？” “笨死了，还要哪种，肯定是小猫咪啊，难道我们家还能像迪拜土豪那样养老虎啊！”你女朋友答道。 “好好， 那你想要哪个品种的猫呢？”你问道。 “我想要国外的品种, 不要中国的土猫” 你女友傲娇的回答到。 这时你已经快奔溃了，作为程序员的你再也受不了这种挤牙膏式的提问，于是你哀求到：“亲爱的，你就直接告诉我你到底想要哪个品种，哪个颜色，多大的猫？” 你女友想了想抖音的那只猫，回答道：“我想要一只银色的，不超过1岁的英短折耳猫！” 于是，你在女友生日当天到文二路花鸟市场里面去，挑了一只“银色的，不超过1岁的英短折耳猫”回家送给了你女友, 圆了你女友拥有网红同款猫的梦! 上面你最终买到并送给女友那只猫可以被看作是一个实例对象，花鸟市场可以看作是一个工厂，我们可以认为它是一个函数，这个工厂函数里面有着各种各样的动物，那么你是如何获取到实例的呢？因为你给花鸟市场传递了正确的参数, “color: 银色”，“age: 不超过1岁”，”breed:英短折耳”，“category: 猫”。前面的对话中, 你女朋友回答动物，猫科动物，国外的品种让你不明白她到底想要什么，就是因为她说得太抽象了。她回答的是一大类动物的共有特征而不是具体动物，这种将复杂事物的一个或多个共有特征抽取出来的思维过程就是抽象。 既然已经明白了抽象的概念，下面我们来看一下之前提到的工厂模式的三种实现方法： 简单工厂模式、工厂方法模式、抽象工厂模式。 简单工厂模式简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。 就以上面的对话例子做个扩展，代码如下： 1234567891011121314151617181920212223var petMarketFactory = function(pet) &#123; function Pet(opt) &#123; this.name = opt.name &#125; switch(pet) &#123; case 'cat': return new Pet(&#123; name: 'cat'&#125;) break; case 'fish': return new Pet(&#123; name: 'fish'&#125;) break; case 'dog': return new Pet(&#123; name: 'dog'&#125;) break; default: throw new Error('参数错误, 可选参数:cat, fish, dog') &#125;&#125;var cat = petMarketFactory('cat')var fish = petMarketFactory('fish')var dog = petMarketFactory('dog') 它的优点在于你只需要一个正确参数，就可以获得你所需要的对象，而无需知道对象创建的具体逻辑。但是在函数内包含了所有对象的创建逻辑（Pet构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。当我们的对象不是上面的3个而是更多时，这个函数会成为一个庞大的超级函数，便得难以维护。所以，简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。 工厂方法模式工厂方法模式可以看作是一个实例化对象的工厂类，代码如下： 1234567891011121314151617181920212223242526272829// 安全模式创建的工厂方法函数var petMarketFactory = function(name, pet) &#123; if (this instanceof petMarketFactory) &#123; var o = new this[name](pet) return o &#125; else &#123; return new petMarketFactory(name, pet) &#125;&#125;// 工厂方法函数的原型中设置所有对象的构造函数petMarketFactory.prototype = &#123; Cat: function(pet) &#123; this.name = \"cat\" this.type = pet &#125;, Fish: function(pet) &#123; this.name = \"fish\" this.type = pet &#125;, Dog: function(pet) &#123; this.name = 'dog' this.type = pet &#125;&#125;var cat = petMarketFactory('Cat', 'animal')var fish = petMarketFactory('Fish', 'animal')var dog = petMarketFactory('Dog', 'animal') 使用上面的模式去进行实例化，就不用担心某个阶段遗忘使用 new 操作导致对象取不到的问题了。 抽象工厂模式上面介绍了简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。 上面例子中的cat，fish，dog三种宠物，其中 cat 商家提供了不同的品种，例如：英短，美短。那么这两个种类就是对应的类簇。在抽象工厂中，类簇一般用父类定义，并在父类中定义一些抽象方法，再通过抽象工厂让子类继承父类。所以，抽象工厂其实是实现子类继承父类的方法。 上面提到的抽象方法是指声明但不能使用的方法。在其他传统面向对象的语言中常用abstract进行声明，但是在JavaScript中，abstract是属于保留字，但是我们可以通过在类的方法中抛出错误来模拟抽象类。 123456var UsaShorthair = function() &#123;&#125;UsaShorthair.prototype = &#123; getName: function() &#123; return new Error('抽象方法不能调用'); &#125;&#125; 上述代码中的 getName 就是抽象方法，我们定义它但是却没有去实现。如果子类继承 UsaShorthair 但是并没有去重写 getName，那么子类的实例化对象就会调用父类的 getName 方法并抛出错误提示。 下面我们分别来实现猫种类管理的抽象工厂方法: 12345678910111213141516171819202122232425262728293031323334var TypeCatFactory = function(subType, superType) &#123; // 抽象工厂中是否有该抽象类 if (typeof TypeCatFactory[superType] === 'function') &#123; function F() &#123;&#125; // 继承父类属性和方法 F.prototype = new TypeCatFactory[superType] () // 子类原型继承父类 subType.prototype = new F() // 子类constructor指向自己 subType.prototype.constructor = subType &#125; else &#123; throw new Error('抽象类不存在') &#125;&#125;// 美短猫抽象类TypeCatFactory.UsaShorthair = function() &#123; this.type = 'USA'&#125;TypeCatFactory.UsaShorthair.prototype = &#123; getName: function() &#123; return new Error('抽象方法不能调用') &#125;&#125;// 英短猫抽象类TypeCatFactory.BritishShorthair = function() &#123; this.type = 'UK'&#125;TypeCatFactory.BritishShorthair.prototype = &#123; getName: function() &#123; return new Error('抽象方法不能调用') &#125;&#125; TypeCatFactory 就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承。对抽象工厂方法添加抽象类的方法我们是通过点语法进行添加的。 下面我们来定义猫的子类: 123456789101112131415161718192021// 美短猫子类function CatOfUsa(name) &#123; this.name = name&#125;// 抽象工厂实现 UsaShorthair 类的继承TypeCatFactory(CatOfUsa, 'UsaShorthair')// 子类中重写抽象方法CatOfUsa.prototype.getName = function() &#123; return this.name&#125;// 英短猫子类function CatOfUk(name) &#123; this.name = name&#125;// 抽象工厂实现 BritishShorthair 类的继承TypeCatFactory(CatOfUk, 'BritishShorthair')// 子类中重写抽象方法CatOfUk.prototype.getName = function() &#123; return this.name&#125; 上述代码我们分别定义了CatOfUsa，CatOfUk两种类。这两个类作为子类通过抽象工厂方法实现继承。特别需要注意的是，调用抽象工厂方法后不要忘记重写抽象方法，否则在子类的实例中调用抽象方法会报错。 我们来分别对这两种类进行实例化，检测抽象工厂方法是实现了类簇的管理。 1234567891011// 实例化美短猫var UsaCatA = new CatOfUsa('美短逗逗')console.log(UsaCatA.getName(), UsaCatA.type) // 美短逗逗 USAvar UsaCatB = new CatOfUsa('美短雪饼')console.log(UsaCatB.getName(), UsaCatB.type) // 美短雪饼 USA// 实例化英短猫var UkCatA = new CatOfUk('英短逗逗')console.log(UkCatA.getName(), UkCatA.type) // 英短逗逗 UKvar UkCatB = new CatOfUk('英短雪饼')console.log(UkCatB.getName(), UkCatB.type) // 英短雪饼 UK 从打印结果上看，TypeCatFactory 这个抽象工厂很好的实现了它的作用，将猫按照不同品种这一个类簇进行了分类。这就是抽象工厂的作用，它不直接创建实例，而是通过类的继承进行类簇的管理。抽象工厂模式一般用在多人协作的超大型项目中，并且严格的要求项目以面向对象的思想进行完成。 ES6中的工厂模式ES6中给我们提供了 class 新语法，虽然 class 本质上是一颗语法糖，并也没有改变 JavaScript 是使用原型继承的语言，但是确实让对象的创建和继承的过程变得更加的清晰和易读。下面我们使用ES6的新语法来重写上面的例子。 ES6重写简单工厂模式12345678910111213141516171819202122232425class PetMarket &#123; constructor(opt) &#123; this.name = opt.name &#125; getInstance(pet) &#123; switch(pet) &#123; case 'cat': return new Pet(&#123; name: 'cat'&#125;) break; case 'fish': return new Pet(&#123; name: 'fish'&#125;) break; case 'dog': return new Pet(&#123; name: 'dog'&#125;) break; default: throw new Error('参数错误, 可选参数:cat, fish, dog') &#125; &#125; &#125;let cat = PetMarket.getInstance('cat')let fish = PetMarket.getInstance('fish')let dog = PetMarket.getInstance('dog') ES6重写工厂方法模式123456789101112131415161718192021222324252627282930313233class PetMarket &#123; constructor(name) &#123; // new.target 指向直接被 new 执行的构造函数 if (new.target === PetMarket) &#123; throw new Erorr('抽象类不能实例化') &#125; this.name = name &#125;&#125;class PetMarketFactory extends PetMarket &#123; constructor(name) &#123; super(name) &#125; create(pet) &#123; case 'cat': return new PetMarketFactory('cat') break; case 'fish': return new PetMarketFactory('fish') break; case 'dog': return new PetMarketFactory('dog') break; default: throw new Error('参数错误, 可选参数:cat, fish, dog') &#125;&#125;let petMarketFactory = new PetMarketFactory()let cat = petMarketFactory.create('cat')let fish = petMarketFactory.create('fish')let dog = petMarketFactory.create('dog') ES6重写抽象工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041class PetMarket &#123; constructor(type) &#123; if (new.target === PetMarket) &#123; throw new Error('抽象类不能实例化') &#125; this.type = type &#125;&#125;class CatOfUsa extends PetMarket &#123; constructor(name) &#123; super('UsaShorthair') this.name = name &#125;&#125;class CatOfUk extends PetMarket &#123; constructor(name) &#123; super('BritishShorthair') this.name = name &#125;&#125;const petMarketFactory = (type) =&gt; &#123; switch (type) &#123; case 'UsaShorthair': return CatOfUsa break; case 'BritishShorthair': return CatOfUk break; default: throw new Error('参数错误, 可选参数:UsaShorthair, BritishShorthair') &#125;&#125;let UsaCatClass = petMarketFactory('UsaShorthair')let UkCatClass = petMarketFactory('BritishShorthair')let UsaCatA = new UsaCatClass('美短雪饼')let UkCatA = new UkCatClass('英短雪饼')","tags":[]},{"title":"JS常用设计模式详解[es5与es6]-构造函数模式（一）","date":"2018-12-17T06:32:11.000Z","path":"2018/12/17/JS常用设计模式详解-es5与es6-构造函数模式（一）/","text":"基本用法js没有类的概念，通常认为构造函数是用来实现实例的，通过 new 关键字来调用构造函数创建一个新对象。构造函数内部的 this 引用的是新创建的对象。 12345678910111213function Player(name, age) &#123; this.name = name this.age = age this.output = function () &#123; return this.name + ' is ' + this.age + ' years old' &#125;&#125;var Irving = new Player('Irving', 18)var Kobe = new Player('Kobe', 18)console.log(Irving.output())console.log(Kobe.output()) 这是个灰常简单的构造函数，所以问题一下就暴漏了。首先继承就麻烦了，其次 output() 每次创建对象的时候都重新定义了，如果有大批量实例的话，内存开销就很大，所以最好的方法是让 Player 实例共享这个 output() 方法 构造函数与原型123456789101112131415161718function Player(name, age) &#123; // 强制使用new if (!(this instanceof Player)) &#123; return new Player(name, age) &#125; this.name = name this.age = age&#125;Player.prototype.output = function () &#123; return this.name + ' is ' + this.age + ' years old' &#125;var Irving = new Player('Irving', 18)var Kobe = new Player('Kobe', 18)console.log(Irving.output())console.log(Kobe.output()) ES6123456789101112131415// 类的声明class Player &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; output() &#123; return this.name + ' is ' + this.age + ' years old' &#125;&#125;// 类实例化let Irving = new Player('Irving', 18)Irving.output()","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"Koa2中间件原理","date":"2018-11-28T08:04:42.000Z","path":"2018/11/28/Koa2中间件原理/","text":"前言最近一直在用koa，就很好奇koa的中间件是如何实现的，多个中间件之间的关系和执行顺序又是怎样的？下面我们一起来看看吧。 举个 🌰 输出就不写了，还不清楚的同学自行尝试下 app.use做了什么过滤掉一些暂时用不到的代码预先通过use方法，将请求可能会经过的中间件装在了一个数组里 callback通过 compose() 这个方法，就将我们传入的中间件数组关联起来了，最后 callback() 返回 this.handleRequest() 的执行结果，暂不管返回什么吧，先看看这个神奇的compose() 方法做了什么使得文章最开始的例子可以那样执行 compose 首先会默认执行第一个中间件，返回 Promise，被 Koa 监听，执行对应逻辑 在执行第一个中间件的逻辑时，遇到 await next()时，会继续执行 dispatch(i+1)，也就是执行 dispatch(1)，会手动触发执行第二个中间件。这时候，第一个中间件 await next() 后面的代码就会被 pending，等待 await next() 返回 Promise，才会继续执行第一个中间件 await next() 后面的代码。 以此类推，如果有多个中间件的时候，会依照上面的逻辑不断执行，先执行第一个中间件，在 await next() 出 pending，继续执行第二个中间件，继续在 await next() 出 pending，继续执行第三个中间，直到最后一个中间件执行完，然后返回 Promise，然后倒数第二个中间件才执行后续的代码并返回Promise，然后是倒数第三个中间件，接着一直以这种方式执行直到第一个中间件执行完，并返回 Promise，从而实现开头例子的执行顺序，就好比下面网上很火的一张洋葱图 总结koa 真香，这 compose() 函数真骚，所以说评价一个好的程序员不是由代码量决定的","tags":[]},{"title":"react服务端渲染","date":"2018-10-06T02:23:02.000Z","path":"2018/10/06/react服务端渲染/","text":"前言最近想了解尝试下服务端渲染，就从熟悉的 react 下手进行 demo 什么是服务端渲染服务端渲染是指页面的渲染和生成由服务器来完成，并将渲染好的页面返回客户端。而客户端渲染是页面的生成和数据的渲染过程是在客户端（浏览器或APP）完成。 为什么要使用服务端渲染 SEO友好 加快首屏渲染，减少白屏时间 SEO又是什么现在的网站大多都是SPA，页面数据都通过ajax来的，搜索引擎的spider来收录网页的时候，发现全是空的话，那么你的网站收录的权重跟效果肯定是不好的 核心思想 起一个 node 服务 把 react 根组件 renderToString 渲染成字符串一起返回前端 前端再重新 render 一次 为什么需要前端再 render 一次事件是在浏览器渲染页面的时候进行挂载的，服务器返回的内容HTML字符串，不在浏览器里再渲染一次的话，事件是不会挂载的 以下示例代码从 demo 里取出，如需查看完整请移步 demo 示例代码babel 的入口，index.js代码如下 123require('babel-core/register')();require('babel-polyfill');require('./app'); 项目入口 app.js代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import Koa from 'koa';import React from 'react';import &#123; renderToString &#125; from 'react-dom/server';import views from 'koa-views'; // 配置模板的中间件import Static from 'koa-static'; // 处理静态文件的中间件import ip from 'ip';import path from 'path';import webpack from 'webpack';import webpackConfig from './webpack.config';import koaWebpack from 'koa-webpack';import Home from './client/components/home';const app = new Koa();const port = 3000;const host = ip.address();// dev 模式热加载app.use(koaWebpack(&#123; compiler: webpack(webpackConfig), hot: &#123; log: () =&gt; &#123;&#125; &#125;, dev: &#123; noInfo: true, serverSideRender: true, hot: true, logLevel: 'error', stats: &#123; colors : true &#125;, publicPath: '' &#125;,&#125;));// dist文件夹设置为静态路径app.use(Static(__dirname + '/dist'));// 使用模板引擎来渲染app.use(views(path.resolve(__dirname, './views'), &#123; map: &#123; html: 'ejs' &#125; &#125;));app.use(async (ctx) =&gt; &#123; let str = renderToString(&lt;Home /&gt;); await ctx.render('index', &#123; root: str &#125;);&#125;);app.listen(port, host, (error) =&gt; &#123; if (error) &#123; console.error(error); &#125; else &#123; console.info('==&gt; 🌎 Listening on port %s. Open up http://%s:%s/ in your browser.', port, host, port); &#125;&#125;); Home 组件代码如下： 1234567891011import React, &#123; Component &#125; from 'react';class Home extends Component &#123; render() &#123; return ( &lt;div onClick=&#123;() =&gt; window.alert('home')&#125;&gt;home!&lt;/div&gt; ) &#125;&#125;export default Home; 我们的渲染模板，新建一个 views 文件夹里面新建一个 index.html： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;SSR&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;%- root %&gt;&lt;/div&gt; &lt;!-- 构建出来的代码--&gt; &lt;script src=\"/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack 配置 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require('path');const webpack = require('webpack');module.exports = &#123; devtool: 'source-map', entry: [ 'react-hot-loader/patch', 'webpack/hot/only-dev-server', `$&#123;__dirname&#125;/client/index.js` ], output: &#123; filename: '[name].js', path: path.join(__dirname, 'dist'), publicPath: '/' &#125;, resolve: &#123; extensions: ['.js', '.jsx'] &#125;, module: &#123; rules: [&#123; test: /\\.jsx?$/, loaders: ['babel-loader'], &#125;, &#123; test: /\\.css$/, include: [path.join(__dirname, 'client')], use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;] &#125;, plugins: [ // new webpack.HotModuleReplacementPlugin(), // 启用 HMR new webpack.NamedModulesPlugin(), new webpack.NoEmitOnErrorsPlugin() ], devServer: &#123; hot: true, inline: true, host: 'localhost', port: 3333, contentBase: path.resolve(__dirname, 'dist') &#125;&#125; 这里面支持 react-router 配置是和客户端有些差别的，这里就不拿出来多讲了，详情请查看 demo，热更新和实时构建也已配置好，后续补上 redux 或者 mobx 的支持，使这个工具链更完善一点。","tags":[{"name":"react","slug":"react","permalink":"//zhoujingchao.github.io/tags/react/"}]},{"title":"JS执行机制详解","date":"2018-06-28T00:57:19.000Z","path":"2018/06/28/JS执行机制详解/","text":"前言前一阵子遇到的面试题，此时再巩固一下 javasrcipt 的执行机制。 12345678910111213141516171819202122232425262728console.log(1)setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(3) resolve() &#125;).then(() =&gt; &#123; console.log(4) &#125;)&#125;)new Promise(resolve =&gt; &#123; console.log(5) resolve()&#125;).then(() =&gt; &#123; console.log(6)&#125;)setTimeout(() =&gt; &#123; console.log(7) new Promise(resolve =&gt; &#123; console.log(8) resolve() &#125;).then(() =&gt; &#123; console.log(9) &#125;)&#125;) 童鞋们可以先自己思考，答案后面再给。 从代码可以看出，理解这个需要以下知识点： javascriptjavascript 是一门 单线程 语言，作为浏览器脚本语言，它的主要用途就是与用户交互，以及操作 DOM ，这个性质也决定了它是单线程，不然多线程的话，就会有很多复杂性的同步问题。为利用多核 CPU 的计算能力，最新的 HTML5 中提出的 Web-Worker 标准，允许 javascript 创建多个线程，但子线程完全受主线程控制，且不得操作 DOM。所以 javascript 是单线程的核心从未改变，一切 javascript 版的 “多线程” 都是单线程模拟出来的。 事件循环既然是单线程就意味着，所有任务都需要排队，前一个任务结束，才能执行后一个任务。如果前一个任务耗时很长，那么后一个任务就不得不一直等待。因此大佬们就把任务分成了两类： 同步: 只有前一个任务执行完毕，才能执行后一个任务 异步: 当同步任务执行到某个 WebAPI 时，会触发异步操作，此时浏览器会单独开线程去处理这些异步任务 下面用最火的导图来补充说明下： 用文字来表述的话： 同步任务进入主线程，异步任务进入 Event Table 注册站进行注册函数 当指定的事情完成时，Event Table 会将这个事情对应的函数移入 Event Queue 这个缓冲区 主线程内的任务执行完为空时，就会去 Event Queue 读取对应的函数，进入主线程执行 js引擎的 monitoring process 进程会持续不断的检查主线程执行栈是否为空，一旦为空，就会去缓冲区检查是否有等待被调用的函数，上述过程会不断重复，也就是常说的 Event Loop (事件循环) 说了这么多，不如来看一段代码： 12345console.log('1')setTimeout(() =&gt; &#123; console.log('2')&#125;, 0)console.log('3') 上面一段简易的 setTimeout 代码： 输出1 遇到 setTimeout 进入 Event Table，注册回调函数 () =&gt; { console.log(‘2’) } 输出3 主线程从 Event Queue 读取回调函数并执行输出2 micro task 与 macro task异步任务的优先级并不相同，它们被分为两类： 微任务（micro task）: 包括整体代码script，setTimeout，serInterval 宏任务（macro task）：Promise，process.nextTick 根据异步事件的类型，这些事件会被派发到对应的微任务和宏任务中，在当前主线程执行完毕后： 首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行 再取 宏任务 周而复始，直至两个队列的任务都取完 老规矩最火的导图来说明： 来看一段代码理解下： 123456789101112setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;)new Promise((resolve) =&gt; &#123; console.log('promise') resolve()&#125;).then(() =&gt; &#123; console.log('then')&#125;)console.log('console') 第一轮事件循环 宏任务 整体script 微任务 then 首先整体script作为宏任务，进入主线程 先遇到 setTimeout 注册后派发到宏任务 再遇到 Promise，new Promise 立即执行，then 函数派发到微任务 console.log(&#39;console&#39;)，立即执行 开始第二轮 宏任务 setTimeout 微任务 无 第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue 开始发现 setTimeout 立即执行 结果输出： 1234promiseconsolethensetTimeout 最后回过头来，让我们再分析下最开始的代码 123456789101112131415161718192021222324252627282930313233console.log(1)// setTimeout1setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(3) resolve() &#125;).then(() =&gt; &#123; // then4 console.log(4) &#125;)&#125;)new Promise(resolve =&gt; &#123; console.log(5) resolve()&#125;).then(() =&gt; &#123; // then6 console.log(6)&#125;)// setTimeout2setTimeout(() =&gt; &#123; console.log(7) new Promise(resolve =&gt; &#123; console.log(8) resolve() &#125;).then(() =&gt; &#123; // then9 console.log(9) &#125;)&#125;) 为了方便下面记录分析，先在代码上做个标记 第一轮事件循环 宏任务： 整体script 微任务：then6 输出1，5，6 第二轮事件循环 宏任务： setTimeout1 微任务：then4 输出2，3，4 第三轮事件循环 宏任务： setTimeout2 微任务：then9 输出7，8，9 总结与思考 javascript 是一门单线程语言 Event Loop是 javascript 的执行机制 在 node 中执行机制又是如何？","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"前端安全CSRF && XSS","date":"2018-04-23T09:04:56.000Z","path":"2018/04/23/前端安全CSRF&&XSS/","text":"前言 随着互联网的发达，各种WEB应用也变得越来越复杂，满足了用户的各种需求，但是随之而来的就是各种网络安全的问题。作为前端工程师的我们也逃不开这个问题。所以今天，就和大家一起聊一聊WEB前端的安全那些事儿。这里就不去说那些后端的攻击(SQL注入、DDOS攻击等)。 为什么要攻击？ 其实真正为了玩的心态去进行黑网站的人，还是少数。多数攻击还是有利益的成分在里面的。开发者不可能确保自己的应用绝对无法被攻击，但是只要攻击我们的时候，骇客花费的成本远比他可以获取的利益大得多，骇客就不会去攻击。防范强如支付宝、QQ等产品，也都曾被报过漏洞，看来防御不是绝对的，我们只能想办法让我们的应用更加安全。 前端攻击形式以及如何防范 CSRF（Cross-site request forgery），通常称为跨站请求伪造 XSS（Cross-site scripting），通常称为跨域脚本攻击 CSRF 攻击原理 如图所示，被攻击的前提就很明了了，用户需要在A网站登录过，并且网站A存在接口漏洞 CSRF 防范因此根据上述进行对症下药进行防范 Token验证 访问接口的时候，浏览器会自动上传cookie，不会上传token，所以进行token验证 Referer验证 服务器判断是否是该站点下的页面，是的话执行，反之拦截 隐藏令牌 跟token有点像，比如把验证信息隐藏在header上 XSS 攻击原理XSS 攻击是 Web 攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实施比如 SQL 注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨大的，是web安全的头号大敌。 Web 应用程序的技术基础是由 HTTP 和 HTML 组成的。HTTP 协议是 HTML 的传输机制，可使用代码设计 Web 页面布局和生成页面。如果 Web 应用程序接受用户通过 HTTP 请求（如 GET 或 POST）提交的输入信息，然后使用输出 HTML 代码在某些地方显示这些信息，便可能存在 XSS 漏洞。 实施 XSS 攻击需要具备两个条件： 需要向web页面注入恶意代码 这些恶意代码能够被浏览器成功的执行 XSS 攻击类型 反射型攻击 恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的 存储型攻击 恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上，但OA系统，和CRM系统上也能看到它身影，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，骇客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击 了解了 XSS 的原理，接下去看看怎么防范吧 XSS 防范 在表单提交或者url参数传递前，对需要的参数进行过滤 过滤用户输入的，检查用户输入的内容中是否有非法内容。如&lt;&gt;、”、 ‘、%、;、()、&amp;、+等。严格控制输出 可以利用下面这些函数对出现 xss 漏洞的参数进行过滤1、htmlspecialchars() 函数,用于转义处理在页面上显示的文本。2、htmlentities() 函数,用于转义处理在页面上显示的文本。3、strip_tags() 函数,过滤掉输入、输出里面的恶意标签。4、header() 函数,使用header(“Content-type:application/json”); 用于控制 json 数据的头部，不用于浏览。5、urlencode() 函数,用于输出处理字符型参数带入页面链接中。6、intval() 函数用于处理数值型参数输出页面中。7、自定义函数,在大多情况下，要使用一些常用的 html 标签，以美化页面显示，如留言、小纸条。那么在这样的情况下，要采用白名单的方法使用合法的标签显示，过滤掉非法的字符。","tags":[{"name":"安全","slug":"安全","permalink":"//zhoujingchao.github.io/tags/安全/"}]},{"title":"vue+vuex+vue-router+express+mongoose编写简单的todolist-demo","date":"2018-01-05T03:38:59.000Z","path":"2018/01/05/vue-vuex-vue-router-express-mongoose编写简单的todolist-demo/","text":"最近对vue和express感兴趣，趁闲暇时间，写了下前后端分离的todolist。写这篇博文来总结思考下，项目地址如下前端：https://github.com/zhoujingchao/vue-router-vuex-todolist后端：https://github.com/zhoujingchao/express-mongoose-todolist 总体概览 相信大家也看到了，实现的功能还是很简单的，整个todolist界面分为左侧导航栏和右侧内容，用户可以切换导航，可以添加任务和删除任务。补充说明下这个demo只是自己摸索vue和express过程中做出的，还是有很多不足的地方，希望大家多多指教。 前端由于这次主要是想玩下vue，就直接用了vue-cli，没有去从头开始配webpack了，想自己实现一边的童鞋们，可以参考着脚手架摸索一下。 vuex简单介绍vuex是给vue开发者提供的状态管理模式，他采用集中式存储管理应用的所用组件状态，通过action来变化。此状态自管理包含下面三个部分： state：应用数据源 view：将state映射到试图 actions：响应view导致的状态变化 这张单一的数据流示意图很好地展现了它们之间的关系 这时有过组件编写经验的童鞋就会提问，应用中多个组件共享状态时，这个单向数据流不就被破坏了？ 1.多个视图依赖同一状态2.来自不同视图的行为需要变更同一状态 问题1，传参的方式对于多层嵌套的组件将会非常繁琐并且对于兄弟组件间的状态传递也无能为力。问题2，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态。以上的这些模式都非常脆弱，通常会导致无法维护的代码。 因此vuex就是用来把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码也会变得更结构化且易维护。 附上经典图例 大致就介绍到这里了，想要深入了解的童鞋们请移步 https://vuex.vuejs.org/zh-cn/下面介绍下todolist-demo的vuex statedemo逻辑很简单，只写了一个。 123export const state = &#123; todoList: []&#125; mutationsmutations只设计状态的改变，不要在这里做异步。 12345678910111213export const mutations = &#123; getTodo (state, todo) &#123; state.todoList = todo &#125;, addTodo (state, todo) &#123; state.todoList.push(todo) &#125;, deleteTodo (state, id) &#123; state.todoList = state.todoList.filter((item) =&gt; item.id !== id) &#125;&#125; actions这里才是与后台交互，进行异步操作的地方 1234567891011121314151617181920212223242526272829303132333435import axios from 'axios'const host = 'http://localhost:9000'export const getTodo = (&#123; commit &#125;) =&gt; &#123; axios.get(`$&#123;host&#125;/todo/get`) .then(res =&gt; &#123; console.log(res) commit('getTodo', res.data.data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125;export const addTodo = (&#123; commit &#125;, data) =&gt; &#123; axios.post(`$&#123;host&#125;/todo/create`, &#123; data: data &#125;).then(res =&gt; &#123; console.log(res) commit('addTodo', data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125;export const deleteTodo = (&#123; commit &#125;, id) =&gt; &#123; axios.post(`$&#123;host&#125;/todo/delete`, &#123; id: id &#125;).then(res =&gt; &#123; console.log(res) commit('deleteTodo', id) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125; gettersdemo里没写，但是这一块主要是将store中的state派生出一些状态，用来复用 页面组件玩了一下下element-ui index.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;el-container&gt; &lt;el-header&gt;&#123;&#123; header &#125;&#125;&lt;/el-header&gt; &lt;el-container&gt; &lt;menus&gt;&lt;/menus&gt; &lt;el-container&gt; &lt;el-main&gt; &lt;router-view /&gt; &lt;/el-main&gt; &lt;el-footer&gt;&#123;&#123; footer &#125;&#125;&lt;/el-footer&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/el-container&gt;&lt;/template&gt;&lt;script&gt;import Menus from './menus'export default &#123; name: 'index', data () &#123; return &#123; header: 'header', footer: 'footer' &#125; &#125;, components: &#123; Menus &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt; .el-container &#123; height: 100%; &#125; .el-header, .el-footer &#123; background-color: #B3C0D1; color: #333; text-align: center; line-height: 60px; &#125; .el-aside &#123; background-color: #545c64; color: #333; text-align: center; line-height: 200px; &#125; .el-main &#123; background-color: #E9EEF3; color: #333; text-align: left; line-height: 50px; &#125; body &gt; .el-container &#123; margin-bottom: 40px; &#125;&lt;/style&gt; menus.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;el-aside width=\"300px\"&gt; &lt;el-menu style=\"width: 100%;\" default-active=\"2\" router class=\"el-menu-vertical-demo\" @open=\"handleOpen\" @close=\"handleClose\" background-color=\"#545c64\" text-color=\"#fff\" active-text-color=\"#ffd04b\"&gt; &lt;el-submenu index=\"1\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-location\"&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;router-link to=\"/1-1\"&gt; &lt;el-menu-item index=\"1-1\"&gt;选项1&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link to=\"/1-2\"&gt; &lt;el-menu-item index=\"1-2\"&gt;选项2&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-menu-item-group&gt; &lt;router-link to=\"/1-3\"&gt; &lt;el-menu-item index=\"1-3\"&gt;选项3&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;el-submenu index=\"1-4\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-location\"&gt;&lt;/i&gt; &lt;span&gt;选项4&lt;/span&gt; &lt;/template&gt; &lt;router-link to=\"/1-4-1\"&gt; &lt;el-menu-item index=\"1-4-1\"&gt;选项1&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;router-link to=\"/2\"&gt; &lt;el-menu-item index=\"2\"&gt; &lt;i class=\"el-icon-menu\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link to=\"/3\"&gt; &lt;el-menu-item index=\"3\"&gt; &lt;i class=\"el-icon-setting\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-menu&gt; &lt;/el-aside&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'menus', data () &#123; return &#123;&#125; &#125;, methods: &#123; handleOpen (key, keyPath) &#123; console.log(key, keyPath) &#125;, handleClose (key, keyPath) &#123; console.log(key, keyPath) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; todo.vue 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=\"todo\"&gt; &lt;el-input type=\"text\" v-model=\"taskInput\" @keyup.enter.native=\"addTask($event)\" placeholder=\"请添加任务\"&gt;&lt;/el-input&gt; &lt;div class=\"list\" v-for=\"todo in todoList\" :todo=\"todo\" :key=\"todo.id\"&gt; &lt;span&gt;&#123;&#123;todo.text&#125;&#125;&lt;/span&gt; &lt;el-button type=\"danger\" size=\"mini\" round @click.native=\"deleteTodo(todo.id)\"&gt;删除该任务&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapActions &#125; from 'vuex'export default &#123; name: 'todo', data () &#123; return &#123; taskInput: '' &#125; &#125;, created () &#123; this.getTodo() &#125;, computed: &#123; ...mapState(['todoList']) &#125;, methods: &#123; addTask (e) &#123; this.$store.dispatch('addTodo', &#123; text: this.taskInput &#125;) this.taskInput = '' &#125;, ...mapActions([ 'getTodo', 'deleteTodo' ]) &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 后端首先准备mongoose 123456789101112131415// https://www.npmjs.com/package/limboconst limbo = require('limbo')const mongoose = require('mongoose')const todoSchema = require('./todo')const url = 'mongodb://127.0.0.1:27017/vue-todo'db = limbo.use('vueTodo', &#123; conn: mongoose.createConnection(url), schemas: &#123; Todo: todoSchema &#125;&#125;)module.exports = limbo todo.js模型 123456789const mongoose = require('mongoose')const Schema = mongoose.Schemaconst todoSchema = Schema(&#123; todoList: &#123; type: Array, &#125;&#125;)module.exports = todoSchema index.js 12345678910111213141516171819202122232425262728293031323334const express = require('express')const mongoose = require('mongoose')const bodyParser = require('body-parser')const port = 9000const app = express()const todo = require('./router/todo')app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.use(bodyParser.json())// 处理跨域app.use(function(req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Methods', 'GET, PUT, POST, DELETE, OPTIONS') res.header('Access-Control-Allow-Headers', 'Origin, Content-Type, X-Requested-With, Authorization, Content-Length') if ('OPTIONS' === req.method) &#123; return res.send(200) &#125; else &#123; return next() &#125;&#125;)app.use('/todo', todo)app.listen(port, function (err) &#123; if (err) &#123; console.error(err) &#125; else &#123; console.info(\"server is running port %s\", port) &#125;&#125;) router这里_id直接从数据库里拿了这张表的id来查询了，各位大佬不用理会我这小白写法。 12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require('express')const router = express.Router()const db = require('../db')const uuidv1 = require('uuid/v1')const &#123; TodoModel&#125; = db.use('vueTodo')router.post('/create', (req, res) =&gt; &#123; const &#123; data &#125; = req.body data.id = uuidv1() const todo = &#123; todoList: data &#125; TodoModel.findOneAndUpdate(&#123; _id: '5a7026137f927103bdad780d' &#125;, &#123; $push: todo &#125;, &#123; upsert: true, new: true &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(400).json(&#123; statusCode: 400, msg: 'save todo failure' &#125;) &#125; return res.status(200).json(&#123; statusCode: 200, msg: 'save todo success' &#125;) &#125;) &#125;)router.get('/get', (req, res) =&gt; &#123; TodoModel.findOne(&#123; _id: '5a7026137f927103bdad780d' &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(400).json(&#123; statusCode: 400, msg: 'get todo failure' &#125;) &#125; return res.status(200).json(&#123; statusCode: 200, data: result &amp;&amp; result.todoList ? result.todoList : [] &#125;) &#125;)&#125;)router.post('/delete', (req, res) =&gt; &#123; const &#123; id &#125; = req.body TodoModel.findOneAndUpdate(&#123; _id: '5a7026137f927103bdad780d' &#125;, &#123; $pull: &#123; todoList: &#123; id: id &#125; &#125; &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(400).json(&#123; statusCode: 400, msg: 'delete todo failure' &#125;) &#125; return res.status(200).json(&#123; statusCode: 200, msg: 'delete todo success' &#125;) &#125;)&#125;)module.exports = router 总结至此，demo结构已经讲的差不多了，说的不对的地方，希望各童鞋指出互相学习。不得不说，vue框架用来真的不错，大家在开发的时候，记住：要从数据的角度思考问题，一切就会变得如此简单。","tags":[{"name":"vue","slug":"vue","permalink":"//zhoujingchao.github.io/tags/vue/"}]},{"title":"深入理解Promise","date":"2017-11-07T05:32:38.000Z","path":"2017/11/07/深入理解Promise/","text":"引子这是一种普遍的获取用户信息的请求处理 12345678910111213// example 1function getUserInfo() &#123; return new Promise(function (resolve) &#123; // an asynchronous request http.get(url, function (res) &#123; resolve(res) &#125;) &#125;)&#125;getUserInfo().then(function (res) &#123; // handle&#125;) getUserInfo方法返回一个promise，可以通过它的then方法注册在promise异步操作成功时执行的回调。这种执行方式，使得异步调用变得顺手. 原理分析那么类似这种功能的Promise是怎么实现的呢？首先看一下最基础的雏形方法吧。 极简的promise雏形12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; // why array -&gt; there are a lot of callbacks sometimes this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled) &#125; function resolve(value) &#123; callbacks.forEach(function(callback) &#123; callback(value) &#125;) &#125; fn(resolve)&#125; 上面的代码逻辑大致这样: 调用then方法，将想要在Promise异步操作成功时执行回调放入callbacks队列，可以理解为注册回调函数，延伸下去向观察者模式思考 创建Promise实例时传入的函数会被赋予一个函数类型的参数，即resolve，他接受一个参数value，代表异步操作返回的结果，当异步操作执行成功 后，会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行 结合中example 1的代码来看，首先new Promise时，传给promise的函数发送异步请求，接着调用promise对象的then属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用resolve(res)方法, 该方法执行then方法注册的回调数组。 那么问题来了有同学会问，then方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用啊。so想让then方法支持链式调用，接着往下看 1234this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled) return this&#125; 只要这样就可以实现链式调用了 123456// example 2getUserInfo().then(function (res) &#123; // handle&#125;).then(function (res) &#123; // handle&#125;) 加入延时机制细心的同学应该发现，上述代码还存在一个问题：如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数： 123456789// example 3function getUserId() &#123; return new Promise(function (resolve) &#123; resolve('gg') &#125;)&#125;getUserInfo().then(function (res) &#123; // handle&#125;) 这显然是不允许的，Promises/A+规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调。我们可以这样改造下resolve函数: 1234567function resolve(value) &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value) &#125;); &#125;, 0)&#125; 上面的代码的思路大家都明白，就是通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成.那么问题又来了某些同学又发现一个问题，可以细想一下：如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的。 加入状态恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的pending、fulfilled、rejected。 Promises/A+规范中的2.1Promise States中明确规定了，pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。改进后的代码如下： 12345678910111213141516171819202122232425function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; onFulfilled(value) return &#125; function resolve(newValue) &#123; value = newValue, state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 上面的代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行。这里没有任何地方将state设为rejected，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。 链式Promise那么这里问题又来了某些同学还会问，如果用户在then函数里面注册的仍然是一个Promise，该如何解决？比如下面的example 4： 12345678910111213getUserInfo() .then(getUserDad) .then(function (res) &#123; // handle &#125;)function getUserDad(userInfoObj) &#123; return new Promise(function (resolve) &#123; http.get(url + userInfoObj.id, function (res) &#123; resolve(res) &#125;) &#125;)&#125; 这种场景相信用过promise的人都知道会有很多，那么类似这种就是所谓的链式Promise。 链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise（后邻promise）。那么我们如何衔接当前promise和后邻promise呢？接着我那会下看：只要在then方法里面return一个promise就好啦。Promises/A+规范中的2.2.7就是这么说哒😊 下面来看看这段暗藏玄机的then方法和resolve方法改造代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;) &#125;) &#125; function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; // nothing in then if(!callback.onFulfilled) &#123; callback.resolve(value) return &#125; var ret = callback.onFulfilled(value) callback.resolve(ret) &#125; function resolve (newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if (typeof then === 'function') &#123; then.call(newValue, resolve) return &#125; &#125; value = newValue, state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 下面结合example 4的代码，分析下上面的代码逻辑： example 4的then方法中，创建并返回了新的Promise实例，这是串行Promise的基础，并且支持链式调用。 handle方法是promise内部的方法。then方法传入的形参onFulfilled以及创建新Promise实例时传入的resolve均被push到当前promise的callbacks队列中，这是衔接当前promise和后邻promise的关键所在（这里一定要好好的分析下handle的作用）。 getUserInfo生成的promise异步操作成功，执行其内部方法resolve，传入的参数正是异步操作的结果即用户信息的对象userInfoObj 调用handle方法处理callbacks队列中的回调：getUserDad方法，生成新的promise（getUserDad promise） 执行之前由getUserInfo promise的then方法生成的新promise(称为bridge promise)的resolve方法，传入参数为getUserDad promise。这种情况下，会将该resolve方法传入getUserDad promise的then方法中，并直接返回。 getUserDad promise异步操作成功时，执行其callbacks中的回调：getUserInfo bridge promise中的resolve方法 最后执行getUserDad bridge promise的后邻promise的callbacks中的回调。 失败处理在异步操作失败时，标记其状态为rejected，并执行注册的失败回调: 1234567891011121314151617// example 5function getUserInfo() &#123; return new Promise(function (resolve, reject) &#123; http.get(url, function (err, res) &#123; if (err) &#123; reject(err) &#125; resolve(res) &#125;) &#125;)&#125;getUserInfo().then(function (res) &#123; // handle res&#125;, function (err) &#123; console.log(err)&#125;) 有了之前处理fulfilled状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled, onRejected) &#123; return new Promise(function (resolve, reject) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve, onRejected: onRejected || null, reject: reject &#125;) &#125;) &#125; function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; var ret, cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; ret = cb(value) callback.resolve(ret) &#125; function resolve (newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if (typeof then === 'function') &#123; then.call(newValue, resolve, reject) return &#125; &#125; value = newValue, state = 'fulfilled'; execute() &#125; function reject (reason) &#123; value = reason, state = 'rejected'; execute() &#125; execute() &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback) &#125;) &#125;, 0) &#125; fn(resolve, reject)&#125; 上面的代码增加了新的reject方法，供异步操作失败时调用，同时抽出了resolve和reject共用的部分，形成execute方法。 错误冒泡是上述代码已经支持，且非常实用的一个特性。在handle中发现没有指定异步操作失败的回调时，会直接将bridge promise(then函数返回的promise，后同)设为rejected状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的： 12345678getUserInfo() .then(getUserDad) .then(function(res) &#123; // handle res &#125; function(err) &#123; // there is something wrong in getUserInfo or getUserDad console.log(err) &#125;) 异常处理细心的同学又会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用try-catch捕获错误，并将bridge promise设为rejected状态。handle方法改造如下： 12345678910111213141516171819202122function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; var ret, cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; try &#123; ret = cb(value) callback.resolve(ret) &#125; catch(e) &#123; callback.reject(e) &#125;&#125; 如果在异步操作中，多次执行resolve或者reject会重复处理后续回调，可以通过内置一个标志位解决。 总结这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。 现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式： 通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。 被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"浏览器输入URL到页面加载的过程","date":"2017-10-13T02:45:16.000Z","path":"2017/10/13/浏览器输入URL到页面加载的过程/","text":"我们平常输入网址到页面展现这里面究竟发生了哪些事情？ 总体来说可以分为以下几个过程： DNS域名解析 TCP连接 服务器处理请求 浏览器解析 绘制页面 具体过程DNS解析DNS解析过程就是寻找哪台机器上有你需要的资源的过程。当你在浏览器中输入一个地址时，例如 www.baidu.com， 其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，由于IP地址并不方便记忆，用户更喜欢用方便记忆的网址去寻找互联网上的其他计算机，也就时上面提到的 www.baidu.com。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，此过程即是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。那么网址到IP地址转换的过程是如何进行的呢？ 解析过程DNS解析是一个递归查询的过程。 上述图片是查找www.baidu.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到baidu的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; baidu.com -&gt; www.baidu.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.baidu.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; baidu.com. -&gt; www.baidu.com.。 DNS优化了解了DNS的过程，可以为我们带来哪些？上文中请求到baidu的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。 DNS缓存DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中。 … DNS负载均衡不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。 TCP连接TCP是互联网中的传输层协议，提供可靠的链接服务，采用三次握手确认一个连接： 浏览器向服务器发送建立连接的请求。 服务器接收到浏览器发送的请求后，像浏览器发送统一连接的信号。 浏览器接受到服务器发出的同意连接的信号后，再次向服务器发出确认连接的信号。 当三次握手返程，TCP客户端和服务端成功的建立连接，就可以开始传输数据了。 服务器处理请求每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。 当web server接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如CGI脚本，JSP脚本，servlets，ASP脚本，服务器端JavaScript，或者一些其它的服务器端技术等）。 无论它们(脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。 那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照MVC设计模式进行搭建的。 处理过程如下图： 对于每一个用户输入的请求，首先被控制器接收，控制器决定用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器确定用哪个视图模型，用相应的视图格式化模型返回html字符串给浏览器，并通过显示页面呈现给用户。 浏览器解析接下来就是浏览器进行处理，通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。 加载浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。 解析解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图： css解析是指将css文件解析为样式表对象。如下图： js解析是文件在加载的同时也进行解析如果想深入如何解析的话可以看浏览器的工作原理：新式网络浏览器幕后揭秘这篇文章 渲染即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。 绘制页面浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上","tags":[{"name":"浏览器","slug":"浏览器","permalink":"//zhoujingchao.github.io/tags/浏览器/"}]},{"title":"JS原型","date":"2017-09-29T12:03:22.000Z","path":"2017/09/29/JS原型/","text":"原型1、原型是什么？js是一门基于对象的脚本语言，但他没有类的概念。js中的对象是无序属性的集合，其属性可以包含基本值，对象或者函数，类似于键值对的集合。有了对象，按理说得有继承啊，不然对象之间没有任何联系了，也就真的沦为键值对的集合了。 我们知道，在js中可以使用构造函数来创建一个新对象，像下面这样： 123456// 构造函数无返回值function Person(name) &#123; this.name = name;&#125;// 通过 new 创建一个新对象var person = new Person('Zhoujc'); new后面跟的不是类，而是构造函数。这里的构造函数可以看作是一种类型，就像面向对象编程语言中的类，但是这样创建的对象除了属性一样外，并没有其他的任何联系，对象之间无法共享属性和方法。每当我们新建一个对象时，都会分配一块新的内存，这是极大的资源浪费。考虑到这点，js的设计者Brendan Eich决定为构造函数设置一个属性。这个属性指向一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里，那些不需要共享的属性和方法，就放在构造函数里。实例对象一旦创建，将自动引用这个对象的属性和方法。也就是说实例对象的属性和方法分成两种，一种本地的，不共享的，另一种是引用的，共享的。这个就对象就是原型（prototype）对象，简称为原型。 我们通过函数声明或函数表达式创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象就是调用构造函数而创建的对象实例的原型。有一个特别的，在ECMA-262规范中，通过Function.prototype.bind创建的函数没有prototype属性。原型可以包含所有实例共享的属性和方法，也就是说只要是原型有的属性和方法，通过调用构造函数而生成的对象实例都会拥有这些属性和方法。看下面代码： 12345678910111213141516function Person(name) &#123; this.name = name;&#125;Person.prototype.age = 20;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;var person1 = new Person('Kobe');var person2 = new Person('Irving');person1.sayName(); // Kobeperson2.sayName(); // Irvingconsole.log(person1.age); // 20console.log(person2.age); // 20 这段代码我们声明了一个Person函数，并在这个函数的原型上添加了age属性和sayName方法，然后生成了两个对象实例Person1和Person2，这两个实例分别拥有自己的属性name和原型的属性age以及方法sayName。所有的实例对象共享原型对象的属性和方法，那么看起来，原型对象就像是类，我们就可以用原型来实现继承了。 2、constructor与[[Prototype]]我们知道每个函数都有一个prototype属性，指向函数的原型，因此当我们拿到一个函数的时候，就可以确定函数的原型。反之，如果给我们一个函数的原型，我们怎么知道这个原型属于哪个函数的呢？这就要说说constructor属性了： 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针 也就是说每个原型都有一个constructor属性，指向了原型所在的函数，拿前面的例子来说Person.prototype.constructor指向Person。下面是构造函数和原型的关系图： 继续，让我们说说[[prototype]]。 当我们调用构造函数创建一个新的实例之后，比如上面例子中的person1，实例的内部会包含一个指针（内部属性），指向构造函数的原型。ECMA-262第5版中管这个指针叫[[prototype]]。我们可以更新函数和原型的关系图： 不过在脚本中没有标准的方式访问[[prototype]]，但在Firefox，Safari和Chrome中可以通过__proto__属性访问。而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 在VSCode中开启调试模式，我们可以看到这些关系： 从上图中我们可以看到Person的prototype属性和person1的__proto__属性是完全一致的，Person.prototype包含了一个constructor属性，指向了Person函数。这些可以很好的印证我们上面所说的构造函数、原型、constructor以及__proto__之间的关系。 3、对象实例与原型了解完构造函数、原型、对象之间的关系后，下面我们来探讨一下对象实例和原型之间的关系。 1、判断对象实例和原型之间的关系因为我们无法直接访问实例对象的__proto__属性，所以当我们想要确定一个对象实例和某个原型之间是否存在关系时，可能会有些困难，好在我们有一些方法可以判断。我们可以通过isPrototypeOf()方法判断某个原型和对象实例是否存在关系，或者，我们也可以使用 ES5 新增的方法Object.getPrototypeOf()获取一个对象实例 __proto__属性的值。看下面的例子: 12console.log(Person.prototype.isPrototypeOf(person1)); // trueconsole.log(Object.getPrototypeOf(person1) === Person.prototype); // true 2、对象实例属性和方法的获取每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例对象中找到了具有给定名字的属性，则返回该属性的值。如果没有找到，则继续搜索__proto__指针指向的原型对象，在原型对象中查找具有给定名字的属性，如果在原型对象中找到了这个属性，则返回该属性的值。如果还找不到，就会接着查找原型的原型，直到最顶层为止。这正是多个对象实例共享原型所保存的属性和方法的基本原理。 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。我们在实例中添加的一个属性，会屏蔽原型中的同名的可写属性，如果属性是只读的，严格模式下会触发错误，非严格模式下则无法屏蔽。另外，通过hasOwnProperty方法能判断对象实例中是否存在某个属性（不能判断对象原型中是否存在该属性）。来看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142function Person() &#123; Person.prototype.name = 'Kobe'; Person.prototype.age = 18; Person.prototype.job = 'NBA player'; Person.prototype.sayName = function () &#123; console.log(this.name); &#125;;&#125;var person1 = new Person();var person2 = new Person();// 设置 phone 属性为不可写Object.defineProperty(person1, 'phone', &#123; write: false, value: '100'&#125;);// 新增一个访问器属性 addressObject.defineProperty(person1, 'address', &#123; set: function (value) &#123; console.log('set'); address = value; &#125;, get: function () &#123; return address; &#125;&#125;);// 注意，此处不能用 name，因为函数本身存在 name 属性console.log(person1.hasOwnProperty('age')); // falseconsole.log(Person.hasOwnProperty('age')); // falseperson1.name = 'Irving';console.log(person1.hasOwnProperty('name')); // trueconsole.log(person1.name); //'Irving'—来自实例console.log(person2.name); //'Kobe'—来自原型person1.phone = '123'; // 严格模式下报错person1.address = 'china'; // 调用 set 方法，输出 'set'console.log(person1.address); // 'china'console.log(person1.phone); // 100 3、in 操作符有两种方式使用 in 操作符： 单独使用 在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 for-in 循环中使用 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性， 也包括存在于原型中的属性。如果需要获取所有的属性（包括不可枚举的属性），可以使用 Object.getOwnPropertyNames() 方法。 看下面例子： 1234567891011121314151617function Person() &#123; this.name = 'Kobe'; Person.prototype.age = 18; Person.prototype.job = 'NBA player'; Person.prototype.sayName = function () &#123; console.log(this.name); &#125;;&#125;var person = new Person();for (var i in person) &#123; console.log(i); // name age job sayName &#125;console.log('name' in person); // true-来自实例console.log('age' in person); // true-来自原型 4、原型的动态性由于在对象中查找属性的过程是一次搜索，而实例与原型之间的连接只不过是一个指针，而非一个副本，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此： 12345var person = new Person();Person.prototype.sayHi = function () &#123; console.log('hi');&#125;;person.sayHi(); // hi 上面的代码中，先创建了Person的一个实例，并将其保存在person中。然后，下一条语句在Person.prototype中添加了一个方法sayHi()。即使person实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。在调用这个方法时，首先会查找person实例中是否有这个方法，发现没有，然后到person的原型对象中查找，原型中存在这个方法，查找结束。 但是下面这种代码所得到的结果就完全不一样了： 123456789101112function Person() &#123;&#125;;var person = new Person();Person.prototype = &#123; constructor: Person, name: \"kobe\", age: 18, job: \"NBA player\", sayName: function () &#123; console.log(this.name); &#125;&#125;;person.sayName(); // error 仔细观察上面的代码，我们直接用对象字面量语法给Person.prototype赋值，这似乎没有什么问题。但是我们要知道字面量语法会生成一个新的对象，也就是说这里的 Person.prototype是一个新的对象，和person的__proto__属性不再有任何关系了。此时，我们再尝试调用sayName方法就会报错，因为person的 __proto__ 属性指向的还是原来的原型对象，而原来的原型对象上并没有sayName方法，所以就会报错。 原型链1、原型的原型在前面的例子，我们是直接在原型上添加属性和方法，或者用一个新的对象赋值给原型，那么如果我们让原型对象等于另一个类型的实例，结果会怎样呢？ 123456789101112131415161718192021function Person() &#123; this.age = '18';&#125;Person.prototype.height = '198cm';function Engineer() &#123; this.work = 'Front-End';&#125;Engineer.prototype = new Person(); // 此时 Engineer.prototype 没有 constructor 属性Engineer.prototype.constructor = Engineer;Engineer.prototype.getAge = function () &#123; console.log(this.age);&#125;var person = new Person();var engineer = new Engineer();console.log(person.age); // 18Engineer.getAge(); // 18console.log(Engineer.height); // 198cmconsole.log(Engineer.prototype.__proto__ === Person.prototype); // true 在上面代码中，有两个构造函数Person和Engineer，可以看作是两个类型，Engineer的原型是Person的一个实例，也就是说Engineer的原型指向了Person的原型。 然后我们分别新建了一个Person和Engineer的实例对象，可以看到engineer实例对象能够访问到Person的 age 和 height 属性，这很好理解： Engineer的原型是Person的实例对象，Person的实例对象包含了 age 属性，而 height 属性是Person原型对象的属性，Person的实例对象自然可以访问原型中的属性，同理，Engineer的实例对象engineer也能访问Engineer原型上的属性，间接的也能访问Person原型的属性。 看起来关系有些复杂，不要紧，我们用一张图来解释这些关系： 是不是一下就很清楚了，顺着图中红色的线，engineer实例对象可以顺利的获取Person实例的属性以及Person原型的属性。至此，已经铺垫的差不多了，我们理解了原型的原型之后，也就很容易理解原型链了。 2、原型链原型链其实不难理解，上图中的红色线组成的链就可以称之为原型链，只不过这是一个不完整的原型链。我们可以这样定义原型链： 原型对象可以包含一个指向另一个原型（原型2）的指针，相应地，另一个原型（原型2）中也可以包含着一个指向对应构造函数（原型2 的构造函数）的指针。假如另一个原型（原型2）又是另一个类型（原型3 的构造函数）的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 结合上面的图，这个概念不难理解。上面的图中只有两个原型，那么当有更多的原型之后，这个红色的线理论上可以无限延伸，也就构成了原型链。 通过实现原型链，本质上扩展了前面提到过的原型搜索机制：当以读取模式访问一个实例的属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 那么原型链的末端又是什么呢？我们要知道，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。我们可以在上面代码的尾部加上一行代码进行验证： 1console.log(Person.prototype.__proto__ === Object.prototype); // true 那Object.prototype的原型又是什么呢，不可能没有终点啊？聪明的小伙伴可能已经猜到了，没错，就是null，null表示此处不应该有值，也就是终点了。我们可以在 Chrome 的控制台或 Node 中验证一下： 1console.log(Object.prototype.__proto__); // null 我们更新一下关系图 至此，一切已经很清楚了，下面我们来说说原型链的用处。 继承继承是面向对象语言中的一个很常见的概念，在阅读前面代码的过程中，我们其实已经实现了简单的继承关系，细心的小伙伴可能已经发现了。在 JavaScript 中，实现继承主要是依靠原型链来实现的。 1、原型链实现一个简单的基于原型链的继承实现看起来是这样的： 1234567891011121314151617181920function Parent() &#123; this.flag = 'parent';&#125;Parent.prototype.getFlag = function () &#123; return this.flag;&#125;function Child() &#123; this.childFlag = 'child';&#125;Child.prototype = new Parent();Child.prototype.getChildFlag = function () &#123; return this.childFlag;&#125;var instance = new Child();console.log(instance.childFlag); // childconsole.log(instance.flag); // parent 原型链虽然很强大，可以实现继承，但是会存在一些问题： 引用类型的原型属性会被所有实例共享。在通过原型链来实现继承时，引用类型的属性会被所有实例共享，一旦一个实例修改了引用类型的值，会立刻反应到其他实例上。由于基本类型不是共享的，所以彼此不会影响。 创建子类型的实例时，不能向父类型的构造函数传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给父类型的构造函数传递参数，我们传递的参数会成为所有实例的属性。 基于上面两个问题，实践中很少单独使用原型链实现继承。 2、借用构造函数为了解决上面出现的问题，出现了一种叫做借用构造函数的技术。这种技术的基本思想很简单：apply()或call()方法，在子类型构造函数的内部调用父类型的构造函数，使得子类型拥有父类型的属性和方法。 123456789101112131415161718function Parent(properties) &#123; this.properties = [].concat(properties); this.nums = [1, 2, 3, 4];&#125;function Child(properties) &#123; // 继承了 Parent，传递参数，互不影响 Parent.apply(this, properties);&#125;var instance1 = new Child(['instance1']);instance1.nums.push(5);console.log(instance1.nums); // 1,2,3,4,5console.log(instance1.properties[0]); // instance1var instance2 = new Child();console.log(instance2.nums); // 1,2,3,4console.log(instance2.properties[0]); // undefined 借用构造函数的确可以解决上面提到的两个问题，实例间不会共享属性，也可以向父类型传递参数，但是这种方法仍然存在一些问题：子类型无法继承父类型原型中的属性。我们只在子类型的构造函数中调用了父类型的构造函数，没有做其他的，子类型和父类型的原型也就没有任何联系。考虑到这个问题，借用构造函数的技术也是很少单独使用的。 3、组合继承上面两个方法能够互补彼此的不足之处，我们把这两个方法结合起来，就能比较完美的解决问题了，这就是组合继承。其背后的思路是使用原型链实现对原型属性的方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性，从而发挥两者，看一个简单的实现： 123456789101112131415161718192021222324252627function Parent(properties) &#123; this.properties = [].concat(properties); this.nums = [1, 2, 3, 4];&#125;Parent.prototype.sayProperties = function () &#123; console.log(this.properties[0]);&#125;function Child(properties) &#123; // 继承了 Parent，传递参数，互不影响 Parent.apply(this, properties);&#125;// 继承父类型的原型Child.prototype = new Parent();// isPrototypeOf() 和 instance 能正常使用Child.prototype.constructor = Child;var instance1 = new Child(['instance1']);instance1.nums.push(5);console.log(instance1.nums); // 1,2,3,4,5instance1.sayProperties(); // instance1var instance2 = new Child();console.log(instance2.nums); // 1,2,3,4instance2.sayProperties(); // undefined 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，是js中最常用的继承模式。组合继承看起来不错，但是也有它的缺点：无论什么情况下，组合继承都会调用两次父类型的构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 4、寄生组合式继承为了解决上面组合继承的问题，一种新的继承方式出现了-寄生组合继承，可以说是 JavaScript 中继承最理想的解决方案。 123456789101112131415161718192021222324252627282930// 用于继承的函数function extend(child, parent) &#123; var F = function () &#123;&#125; F.prototype = parent.prototype; child.prototype = new F(); child.prototype.constructor = child;&#125;// 父类型function Parent(name) &#123; this.name = name; this.nums = [1, 2, 3, 4];&#125;Parent.prototype.sayName = function () &#123; console.log(this.name);&#125;// 子类型function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;var parent = new Parent('baba');var child = new Child('erzi', '18');// 继承原型上的属性和方法extend(child, parent);Child.prototype.getAge = function () &#123; console.log(this.age);&#125;console.log(parent.name); // babaconsole.log(child.name); // erziconsole.log(child.getAge()); // 18 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过借用临时构造函数来继承原型。其背后的基本思路是：不必为了指定子类型的原型而调用父类型的构造函数，我们所需要的无非就是父类型原型的一个副本而已。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"数组扁平化","date":"2017-09-04T07:18:25.000Z","path":"2017/09/04/数组扁平化/","text":"扁平化数组的扁平化，就是将一个嵌套多层的 array 转换为只有一层的 array 举个 🌰 ：有个 flatten 函数做扁平化 12var arr = [1, [2, [3, 4], 5]];console.log(flatten(arr)) // [1, 2, 3, 4, 5] 递归我们最开始能想到的莫过于循环数组元素，如果还是数组，就递归调用该方法： 12345678910111213var arr = [1, [2, [3, 4], 5]];function flatten(arr) &#123; var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])); &#125; else &#123; result.push(arr[i]); &#125; &#125; return result;&#125; reduce既然是对数组做处理，最终返回值，可以考虑用 reduce 来简化代码： 12345function flatten(arr) &#123; return arr.reduce((prev, curr) =&gt; &#123; return prev.concat(Array.isArray(curr) ? flatten(curr) : curr); &#125;, [])&#125; ES6扩展运算符用于取出参数对象的所有可遍历属性，拷贝到当前对象中 12var arr = [1, [2, [3, 4], 5]];console.log([].concat(...arr)); // [1, 2, [3, 4], 5] 这种方法只可以扁平一层，所以要进行扩展 12345678var arr = [1, [2, [3, 4], 5]];function flatten(arr) &#123; while (arr.some((item) =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125;console.log(flatten(arr)); // [1, 2, 3, 4, 5] toString如果数组元素都是数字的话可以尝试： 1234567[1, [2, [3, 4], 5]].toString() // \"1,2,3,4,5\"var arr = [1, [2, [3, 4], 5]];function flatten(arr) &#123; return arr.toString().split(',').map(item =&gt; +item);&#125;console.log(flatten(arr)); // [1, 2, 3, 4, 5]","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"函数节流和防抖了解一下","date":"2017-08-30T03:28:54.000Z","path":"2017/08/30/函数节流和防抖了解一下/","text":"问题引入问题1: 实现dom拖拽功能，但是绑定在拖拽事件的时候每当元素稍微移动一点便触发了大量的毁回调函数，导致浏览器卡死。问题2: 用户连续输入时需要AJAX请求问题。 像这种场景实在是太常见了，为了应对便出现了 函数节流 和 函数防抖 这两个概念，总的来说：这两个方法是在时间轴上控制函数的执行次数。 应用场景对于函数节流（throttle）： 游戏中的刷新率 dom元素拖拽 监听滚动事件判断是否到页面底部自动加载更多内容 让一个函数不要执行得太频繁，减少一些过快的调用来节流，间隔时间段触发，有规律的执行。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;函数节流&lt;/title&gt; &lt;style&gt; body &#123; height: 4000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var time = +new Date(); function count() &#123; console.log(\"函数调用:\" + (+new Date() - time)); &#125; // 节流 控制执行间隔时间 防止频繁触发 scroll resize mousemove let throttle = (fn, delay) =&gt; &#123; let context = this, startTime = 0; return function() &#123; let curTime = new Date(); if (curTime - startTime &gt;= delay) &#123; fn.apply(context, arguments); startTime = curTime; &#125; &#125; &#125; window.onscroll = throttle(count, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 对于函数防抖（debounce）： 防止表单多次提交 防止输入框连续输入进行AJAX请求 窗口缩放 对于一定时间段的连续的函数调用，只让其执行一次，适合多次事件一次响应的情况。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;函数防抖&lt;/title&gt; &lt;style&gt; body &#123; height: 4000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onscroll = function () &#123; console.log('scroll滑动'); debounce(count, 300); &#125; function count() &#123; console.log('函数调用'); &#125; function debounce(fn, wait) &#123; let context = this; clearTimeout(fn.tId); fn.tId = setTimeout(function () &#123; fn.call(context) &#125;, wait) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们滚动页面时，频繁触发了多次的函数调用，如果函数调用中涉及到了dom操作或者接口请求的话，那就爆炸了。所以用防抖，让他停止滑动后，定时结束才执行函数处理逻辑。 总之，巧用函数节流方式能够显著得提高页面性能以及交互体验。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"柯里化实现","date":"2017-08-14T09:31:45.000Z","path":"2017/08/14/柯里化实现/","text":"首先介绍下什么是函数柯里化。《Javascript忍者秘籍》中，对于函数柯里化的定义如下： 在一个函数中首先填充几个参数(然后再返回一个新函数)的技术称为柯里化(Currying)。 场景一实现一个加法函数： 1add(1)(2)(3,4)(5,6,7)() // 28 首先可以看到这个函数只有当参数为空时，才执行之前所有数值的加法，并且这样的嵌套可以无限进行。那么，返回值在参数不为空的时候必定返回一个函数，该函数还保存了之前的参数，这就需要闭包。 实现原理： 闭包保存args变量，存储之前的参数 新建_add函数，无参数的时候执行算法，否则存储参数到args，然后返回函数自身 1234567891011121314151617function add() &#123; // 利用闭包，不断保存arguments let args = [].slice.call(arguments); let _add = function () &#123; // 参数为空执行加法 if (arguments.length === 0) &#123; return args.reduce((a, b) =&gt; &#123; return a + b; &#125;) &#125; else &#123; // 保存参数到args，返回一个函数 [].push.apply(args, arguments); return _add &#125; &#125; return _add&#125; 场景二Dom操作中的时间绑定 1234567891011let addEvent = function(el, type, fn, capture) &#123; if (window.addEventListener) &#123; el.addEventListener(type, (e) =&gt; &#123; fn,call(el, e); &#125;, capture); &#125; else if (window.attachEvent) &#123; el.attachEvent(`on$&#123;type&#125;`, (e) =&gt; &#123; fn.call(el, e); &#125;); &#125;&#125; 这样的实现无可厚非，但是有个缺点，每次绑定都要进行一次 if-else 的操作，显然是没必要的，所以可以通过函数的柯里化改造下： 123456789101112131415let addEvent = (function() &#123; if (window.addEventListener) &#123; return function(el, type, fn, capture) &#123; el.addEventListener(type, (e) =&gt; &#123; fn.call(el, e); &#125;, capture); &#125;; &#125; else if (window.attachEvent) &#123; return function(el, type, fn, capture) &#123; el.attachEvent(`on$&#123;type&#125;`, (e) =&gt; &#123; fn.call(el, e); &#125;); &#125;; &#125;&#125;)(); 通用的函数来对普通函数进行柯里化柯里化特点很明显需要一个闭包保存参数，一个函数来进行递归，这种模式是可以通过一个包装函数，对一些基本的函数进行包装之后具有curry的特性。 1234567891011121314151617181920212223// 通用的函数柯里化构造方法function curry(func) &#123; // 第一个参数是要被柯里化的函数，需要拿掉 let args = [].slice.call(arguments, 1); // 新建_func函数作为返回 let _func = function () &#123; if (arguments.length === 0) &#123; return func.apply(this, args); &#125; else &#123; [].push.apply(args, arguments); return _func; &#125; &#125; return _func;&#125;function add() &#123; return [].reduce.call(arguments, (a, b) =&gt; &#123; return a + b; &#125;);&#125;curry(add)(1)(2,3)() 柯里化的好处 延迟计算 参数复用，当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化选择 动态创建函数","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"如何提高页面性能","date":"2017-07-23T03:13:30.000Z","path":"2017/07/23/如何提高页面性能/","text":"前言关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading是必要的。人处于“开始转移注意力”时，loading就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到loading。loading要有，但不能常有。 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议提高页面性能的方法有哪些大致可归类为以下几类： 资源压缩合并，减少HTTP请求 异步加载 利用浏览器缓存 使用CDN 预解析DNS 资源压缩合并，减少HTTP请求顾名思义即是变小资源，减少请求 异步加载1）动态脚本加载2）defer，在HTMl解析完之后才会执行，如果多个，按照加载顺序依次执行3）async，在加完之后立即执行，如果是多个，执行顺序和加载顺序无关 浏览器缓存浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。这个点是提升性能最重要的一点了，如果缺失这个，前面的资源压缩合并都起不到没什么作用了。 它又是如何判断是否使用缓存的呢？见下图： 优点有： 减少了冗余的数据传输，节省了网费 减少了服务器的负担，大大提升了网站的性能 加快了客户端加载网页的速度 缓存的分类： 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码; 协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源； 两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。 都是通过http response header中的参数来设置的 强制缓存Expires：过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。cache-control除了该字段外，还有下面几个比较常用的设置值：-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。-public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。-private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 协商缓存Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定是否命中协商缓存。 cdn加速维基百科给出的解释是： 内容分发网络（Content delivery network或Content distribution network，缩写：CDN）。简单来说它主要的工作是把我们需要被分发的内容分发到世界各地的各个节点上，让世界各地的人都可以在距离最近的网络节点拿到想要拿到的内容，减少网络传输距离从而达到加速的目的。 前端需要被加速的文件大致包括 js、css、图片、视频、和页面等文件，先聊聊js、css、图片和视频文件。这些文件和页面（html\\jsp\\aspx等）最大的区别是：这些文件都是静态的，改动较小，这类静态文件最适合做cdn加速。我们把这些静态文件通过cdn分发到全国乃至世界的各个节点，用户就可以在距离最近的边缘节点拿到所需要的内容，从而提升内容下载速度加快网页打开速度达到性能优化的目的。接下来我们聊聊页面，页面分动态页面(如：jsp等)和静态页面（html） 动态页面：当收到用户请求时服务器会在服务端对页面进行一次后台渲染把数据渲染到页面之后再返回给用户（当然，服务端也可以做缓存）。静态页面：收到用户请求时，服务端不做渲染工作直接返回给用户。 动态页面是不适合做cdn加速的。原因：由于页面是动态的，内容的有效期就比较活跃。假如我们对动态页面做了cdn加速，那么场景应该是这样的：用户——&gt;边缘节点（验证有效期发现失效）——&gt;源站。经过这个过程才能拿到页面，这样并没有起到加速的作用反而更慢了，那我们还不如直接去源站拿。 预解析DNSDNS解析时间可能导致大量用户感知延迟，DNS解析所需的时间差异非常大，延迟范围可以从1ms（本地缓存结果）到普遍的几秒钟时间。所以利用DNS预解析是有意义的。 浏览器对网站第一次的域名DNS解析查找流程依次为：浏览器缓存-系统缓存-路由器缓存-ISP DNS缓存-递归搜索 实现方式： 用meta信息来告知浏览器, 当前页面要做DNS预解析: &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; 在页面header中使用link标签来强制对DNS预解析: &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt; 注：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。","tags":[{"name":"性能","slug":"性能","permalink":"//zhoujingchao.github.io/tags/性能/"}]},{"title":"移动端webApp踩坑之记","date":"2017-07-06T15:32:02.000Z","path":"2017/07/06/移动端webApp踩坑之记/","text":"记录一下第一次开发hybrid app，遇到的一些坑。 一、H5与Native交互由于初期项目比较急，没有仔细考虑jsbridge技术。 ios直接很粗暴的通过协议 localtion.href = jsbridge://methodName?param1=value1&amp;param2=value2 来解决问题 android就让原生提供一个Android的类，是暴露在window下来调用的 然后就balabalabala…开始爬坑咦，这什么鬼？怎么我连续多次发起location.href的协议，ios只能接收到最后一次请求？妈蛋，那我就不连续发咯。怎么我在路由跳转的时候做些协议会偶尔不起作用，ios接收不到？强行添加123setTimeout(function() &#123; localtion.href = 'jsbridge://methodName?param1=value1&amp;param2=value2';&#125;, 0); wtf？？？ 想想就不对劲呢，\b后面利用业余时间查找了下jsbridge相关资料，才恍然大悟。原来js调用oc或swift有3两种方式： 通过 localtion.href 通过 iframe 方式； ios7新加的 JavaScriptCore 参考链接，提供一个类供js直接调用 通过location.href有个问题，就是如果我们连续多次修改window.location.href的值，在Native层只能接收到最后一次请求，前面的请求都会被忽略掉，不推荐使用。 js调用java： 通过schema方式，使用shouldOverrideUrlLoading方法对url协议进行解析。这种js的调用方式与ios的一样，使用iframe来调用native代码。完整的URL Scheme协议格式：xl://goods:8888/goodsDetail?goodsId=10011002通过上面的路径 Scheme、Host、port、path、query全部包含，基本上平时使用路径就是这样子的。xl代表该Scheme 协议名称goods代表Scheme作用于哪个地址域goodsDetail代表Scheme指定的页面goodsId代表传递的参数8888代表该路径的端口号 提供一个类给js直接调用 简单示例iframe封装： 123456789101112/** * @param &#123;string&#125; fname */export function postWebviewData(fname) &#123; let wvIframe = document.createElement(‘iframe’); wvIframe.style.display = ‘none’; waiframe.src = `jsbridge://$&#123;fname&#125;?param1=value1&amp;param2=value2`; document.body.appendChild(wvIframe); setTimeout(function() &#123; document.body.removeChild(wvIframe); &#125;, 0);&#125; 具体协议和native商量如何传参，再进行封装就好，然后就能快乐的玩耍了辣。其实我还是建议童鞋们，把ios和android都统一起来用同一种方式。 二、WebView 性能优化1. WebView的启动到js解析，编译，执行，消耗的时间比较久，然后呈现在眼前就是这么几个状态： 交互无反馈 到达新的页面，页面白屏 页面基本框架出现，但是没有数据；页面处于loading状态 最后出现所需的数据 解决思路： h5做的是单页面，所以h5首先做了按需加载，接着WebView也做了按需加载，这样就快很多了，时间大概在1-2s， 刚启动的时候就补了个动画页弥补这1-2s的加载 原生和h5都需要做本地缓存使页面和图片呈现的更快，再做数据请求更新 2. 点击延迟在WebView中，click通常会有大约300ms的延迟（包括链接的点击，表单的提交，控件的交互等任何用户点击行为）。 解决思路参考链接: fastclick 三、在ios中，输入状态时，h5定位属性fixed失效```12345678910111213141516171819&lt;div&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header class=\"header\"&gt; 我是头部 &lt;/header&gt; &lt;!-- 可以滚动的区域 --&gt; &lt;main class=\"main\"&gt; &lt;!-- 内容在这里... --&gt; &lt;/main&gt; &lt;!-- fixed定位的底部 --&gt; &lt;footer class=\"footer\"&gt; &lt;div class=\"textarea needsclick\" contentEditable=\"true\" suppressContentEditableWarning&gt;&lt;/div&gt; &lt;button onclick=\"handleClick()\"&gt;发送&lt;/button&gt; &lt;/footer&gt;&lt;/div&gt; 网上也查得到相关解决方案比如：http://efe.baidu.com/blog/mobile-fixed-layout/但是我也不知道为什么我按这个思路来，还是解决不了这个问题，有些人说可以解决，有些人说解决不了，就是这么的奇葩，或许是我姿势不对吧。=_=!! so，还是自己尝试摸索解决，我的布局header和footer是fixed，中间可滚动的区域是relative，算了不说了，直接上代码吧。12345678910111213141516171819202122// listenFocus和listenBlur是给可编辑div添加的聚焦和失焦的事件监听listenFocus = () =&gt; &#123; if (isiOS) &#123; let clientHeight = document.querySelector('.main').clientHeight // 高保真给的是2x的图，头部和底部的高度都是100px，所以中间的可视高度如下 let availHeight = (clientHeight - 200) / 2 // 此定位解决方案，当内容达不到滚动时，输入框就会移动，所以判断下内容高度是否达到滚动条件 if (availHeight &gt; window.screen.availHeight) &#123; // 巨坑啊！fuck this！fixed属性失效，千辛万苦摸索定位解决 document.querySelector('.footer').style.position = 'relative' document.querySelector('.main').style.paddingBottom = '0' &#125; // 原生键盘弹起后, 操作时高度会不一样，使输入框始终不会被键盘遮挡 timerId = setInterval(function() &#123; document.body.scrollTop = document.body.scrollHeight &#125;, 100) &#125;&#125; listenBlur = () =&gt; &#123; if (isiOS) &#123; clearInterval(timerId) &#125; 建议移动端用flex布局 四、在ios中，h5底部输入框被原生键盘遮挡问题参考链接 https://segmentfault.com/a/1190000006243816项目中解决代码123456789/** * 原生键盘弹起后, 操作时高度会不一样，使输入框始终不会被键盘遮挡 */ timeoutToInterval = () =&gt; &#123; this.timerId = setTimeout(() =&gt; &#123; document.body.scrollTop = document.body.scrollHeight this.timeoutToInterval() &#125;, 100)&#125; 五、ios系统11以上，如果有原生底部栏的话，底部就会被抬高具体操作是原生scrollView里的contentInsetAdjustmentBehavior导致的下面是oc代码：12345if (version &gt; 11) &#123; self.webview.scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125;else&#123; self.automaticallyAdjustsScrollViewInsets = NO;&#125;","tags":[{"name":"移动端","slug":"移动端","permalink":"//zhoujingchao.github.io/tags/移动端/"}]},{"title":"一道经典的js面试题","date":"2017-03-24T02:08:51.000Z","path":"2017/03/24/一道经典的js面试题/","text":"废话不多说，直切主题 1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); 输出？ 123456Wed Jan 24 2018 10:13:53 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5 循环执行过程中，几乎同时设置了5个定时器，这些定时器一般情况下都会在1秒之后触发，而循环完的输出是立即执行的。所以先输出了5，1秒之后输出5个5。这里考查了js异步代码，变量作用域，定时器工作机制的理解。 如果期望代码输出：5 -&gt; 0,1,2,3,4，该怎么改造？熟悉闭包的同学很快能给出下面的解决方案： 123456789for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(new Date, j); &#125;, 1000); &#125;)(i);&#125;console.log(new Date, i); 这里利用了立即执行函数的表达式来解决闭包，当然还可以利用js中基本类型的参数是按值传递的特征来改造： 1234567891011var output = function (i) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 5; i++) &#123; output(i);&#125;console.log(new Date, i); 接着还可以衍生出ES6的考察： 1234567for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); 这里只有个非常细微的变动，即使用 ES6 块级作用域 中的 let 替代了 var，但是代码在实际运行时第二段 console.log(new Date, i) 会报错，因为最后那个输出使用的 i 在其所在的作用域中并不存在，i 只存在于循环内部。 下面再进行扩展要求循环和两处 console 不变，要求代码执行时立即输出0，之后每隔1秒依次输出1，2，3，4，循环结束后，大概在第5秒输出5 12345678910111213141516171819202122232425let tasks = [];// let output = (i) =&gt; new Promise(resolve =&gt; &#123;// setTimeout(() =&gt; &#123;// console.log(new Date, i);// resolve();// &#125;, 1000 * i);// &#125;)for (var i = 0; i &lt; 5; i++) &#123; // tasks.push(output(i)); ((j) =&gt; &#123; tasks.push(new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, j); resolve(); &#125;, 1000 * j); &#125;)); &#125;)(i);&#125;Promise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000);&#125;); 既然到 Promise 了，那我们是不是应该用下 ES7 中的 async await 特性来实现一下下呢。 12345678910111213const asyncFn = (time) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, time);&#125;); // 这个分号必须写，不然下面的立即表达式会融合到setTimeout函数中，如果使用大括号return new promise使之闭合，就不会有这个问题了(async () =&gt; &#123; for (var i = 0; i &lt; 5; i++) &#123; await asyncFn(1000); console.log(new Date, i); &#125; await asyncFn(1000); console.log(new Date, i);&#125;)();","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"JS基本面试题","date":"2017-03-13T07:32:31.000Z","path":"2017/03/13/JS基本面试题/","text":"1、typeof a === ‘object’ 来确定a是否是对象的问题?在js中，null这个数据类型也被认为是对象 12let a = nullconsole.log(typeof a === 'object') // true 2、下面代码控制台输出什么，为什么？12345(function()&#123; let a = b = 3&#125;)()console.log(\"a: \" + (typeof a !== 'undefined'))console.log(\"b: \" + (typeof b !== 'undefined')) 大部分开发人员会理解成 12let b = 3let a = b 事实上是 12b = 3let a = b 所以你不使用严格模式的话，该代码输出 12a: falseb: true use strict下，就会报error，ReferenceError: b is not defined 3、下面代码控制台输出什么，为什么？12345678910111213let obj = &#123; a: 'a', func: function() &#123; var _this = this console.log(\"outer func: this.a = \" + this.a) console.log(\"outer func: _this.a = \" + _this.a) (function() &#123; console.log(\"inner func: this.a = \" + this.a) console.log(\"inner func: _this.a = \" + _this.a) &#125;()) &#125;&#125;obj.func() 输出结果如下： 1234outer func: this.a = aouter func: _this.a = ainner func: this.a = undefinedinner func: _this.a = a 在outer函数中，this和_this都指向了obj，所以能正确引用，在inner函数中，this的指向是window，_this的指向还是obj。 4、封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？这是必须这么做的，现在的js库实在是太多了并且还会越来越多，像这样创建的闭包，就是创建了一个私有的命名空间，从而避免模块与库之间的命名冲突。特点是，允许一个易于引用的别名用于全局变量，例如 1(function(yourSymbol) &#123; /* yourPluginName plugin code */ &#125; )(yourPluginName) 5、在JavaScript源文件的开头包含 ‘use strict’ 有什么意义和好处？use strict 是一种在js代码运行时自动实行更严格解析和错误处理的方法。优点： 使调试更加容易，那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。在严格模式下，引用 null或未定义的 this 值会抛出错误。 不允许重复的属性名称或参数值。当检测到对象（例如，var obj = {foo: “bar”, foo: “baz”}）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。 在delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。 6、以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？12345678910111213function fn1() &#123; return &#123; dog: 'hello' &#125;&#125;function fn2() &#123; return &#123; dog: 'hello' &#125;&#125;console.log(fn1())console.log(fn2()) 结果如下： 12&#123;dog: \"hello\"&#125;undefined 原因是在js中，return语句的代码行\b后面没有其他代码的时候，分号会自动插入到返回语句之后，因此也不会抛出错误，fn2()里return下面的代码就是一个未使用得代码块。 7、下列代码输出什么？为什么？12console.log(0.1 + 0.2)console.log(0.1 + 0.2 == 0.3) 本题考查的是js中浮点数的计算精度问题先看下输出 120.30000000000000004false 这不是语言的bug或者宿主环境的bug。目前所有的程序设计语言在对浮点数进行四则运算时，都会涉及到浮点数精确度的问题。我们知道在计算机的世界中，计算机只认识0，1，我们传入的十进制数字并不会被计算机直接识别。计算机会先将其转换成二进制，然后使用转换后的二进制进行计算。那么0.1和0.2转换成二进制分别是， (0.1) =&gt; 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101 (0.2) =&gt; 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 01 然后对上面的两个二进制数字做加法，得到的结果是， 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 01 再把这个二进制转换成十进制，就是我们前面的结果0.30000000000000004了。 8、 下列代码行1-4如何排序，为什么？123456(function() &#123; console.log(1) setTimeout(function()&#123;console.log(2)&#125;, 1000) setTimeout(function()&#123;console.log(3)&#125;, 0) console.log(4)&#125;)() 结果如下： 12341432 \bsetTimeout() 会把其引用的函数的执行放到事件队列中，当它的第二个参数为0时，意思是尽快执行指定的函数，具体而言，函数的执行会放置在事件队列的下一个计时器开始，但是请注意，这不是立即执行，函数不会被执行除非下一个计时器开始。这就是为什么在上述的例子中，用 console.log(4) 发生在调用 console.log(3) 之前（因为调用 console.log(3) 是通过setTimeout被调用的，因此会稍微延迟） 9、写一个简单的函数（越简洁越好），要求返回一个布尔值指明字符串是否为回文结构。123456\bfunction isPalindrome(str) &#123; // 排除\b非单词字符 str = str.replace(/W/g, '').toLowerCaxe() str.split('').reverse().join('') return str&#125; 10、写一个add方法，下面的调用，都能正常输出12console.log(add(2, 3)) //5console.log(add(2)(3)) //5 123456789function add(x, y) &#123; if (y) &#123; return x + y &#125; else &#123; return function(y) &#123; return x + y &#125; &#125;&#125; 11、\b请看下面代码片段12345678for (var i = 0; i &lt; 5; i++) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode('button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125; 1)当用户点击\bbutton4的时候会输出什么到控制台，为什么？ 无论点击哪个按钮，数字5将总会输出到控制台。这是因为，当 onclick 方法被调用（对于任何按钮）的时候， for 循环已经结束，变量 i 已经获得了5的值 2）提供一个或多个备用的可按预期工作的实现方案。 要让代码工作的关键是，通过传递到一个新创建的函数对象，在每次传递通过 for 循环时，捕捉到 i 值。下面是三种可能实现的方法： 12345btn.addEventListener('click', (function(i) &#123; return function() &#123; console.log(i) &#125;&#125;)(i)) 12345(function(i) &#123; brn.addEventListener('click', function() &#123; console.log(i) &#125;)&#125;)(i) 123456['a', 'b', 'c', 'd', 'e'].forEach(function (value, i) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode('button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125;); 12、下面的代码输出什么到控制台，为什么？123456let arr1 = 'john'.split('')let arr2 = arr1.reverse()let arr3 = 'jones'.split('')arr2.push(arr3)console.log('arr1.length: ' + arr1.length + ' last=' + arr1.slice(-1))console.log('arr2.length: ' + arr2.length + ' last=' + arr2.slice(-1)) 结果如下： 12arr1.length: last=j,o,n,e,sarr2.length: last=j,o,n,e,s \barr1和arr2执行完后，两者相同，原因如下： 调用数组对象的 reverse() 方法并不只返回反顺序的阵列，它也反转了数组本身的顺序 reverse() 方法返回一个到数组本身的引用（在这种情况下即，arr1）。其结果为，arr2 仅仅是一个到 arr1的引用（而不是副本）。因此，当对 arr2做了任何事情（即当我们调用 arr2.push(arr3);）时，arr1 也会受到影响，因为 arr1 和 arr2 引用的是同一个对象。 13、下面的代码输出什么到控制台？为什么？123456console.log(1 + '2' + '2')console.log(1 + +'2' + '2')console.log(1 + -'1' + '2')console.log(+'1' + '1' + '2')console.log( 'A' - 'B' + '2')console.log( 'A' - 'B' + 2) 结果如下： 123456\b1223202112NaN2NaN","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"CSS盒模型的认识","date":"2017-02-21T07:21:37.000Z","path":"2017/02/21/CSS盒模型的认识/","text":"前言CSS是前端工程师绕不开的话题，呈现在人们眼前的网页布局，可都离不开它的功劳。 今天我们就来探讨一下对CSS盒模型的认识。 何为CSS盒模型网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 基本概念浏览器解析CSS有两种模式：标准模式(strict mode) 和 怪异模式(quirks mode)。因此就产生了两种盒模型 标准盒模型 和 IE盒模型。 标准模式：浏览器按W3C标准解析执行代码。示意图如下： 怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。示意图如下： 浏览器解析时使用标准模式还是怪异模式，与网页中的DTD（Document Type Defination）声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相关的方式加载网页并显示，忽略DTD声明，将使网页进入怪异模式。 当然也可以通过css来设置盒模型：box-sizing: content-box;box-sizing: border-box;前者就是标准模型，后者是IE模型。 JS如何获取盒模型的宽和高dom为html里获取到的节点 dom.style.width/height，通过dom节点的style属性拿到 dom.currentStyle.width/height，浏览器渲染后的宽高，仅IE支持 window.getComputedStyle(dom).width/height，原理同第二条，兼容第二种写法 dom.getBoundingClientRect().width/height，用与计算元素的绝对位置，也能拿到宽高 盒模型的边距重叠 假如这里有两个元素，子元素高度100px，margin-top为10px，那么它的父元素高度是多少呢？这里我暂时先不给答案，后面再给。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .parent &#123; background: #ff9999; &#125; .child &#123; background: #ffcc99; height: 100px; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到父元素是100px，是吧，嗯，没毛病。接着在父元素parent上加上 overflow: hidden 属性我们再看看效果 父元素是不是变成110px了，嗯？，你接着说，我在听…这是为什么呢？其实给父级加了 overflow: hidden 即给这个元素创建了 BFC。 BFC那么什么是 BFC 呢？BFC 即 Block Formatting Contexts (块级格式化上下文)具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .parent &#123; background: #ff9999; overflow: hidden; &#125; .parent &gt; p &#123; background: #ffcc99; margin: 5px auto 20px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- BFC垂直方向边距重叠 --&gt; &lt;div class=\"parent\"&gt; &lt;p&gt;A&lt;/p&gt; &lt;p&gt;B&lt;/p&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 是不是可以发现 B 的上边距和 A 的下边距发生了重叠，按照重叠原则会取最大的像素即时如上20px。那么要如何解决这个呢，不让他们重叠，那就是给元素创建 BFC。 12345678910&lt;body&gt; &lt;!-- BFC垂直方向边距重叠 --&gt; &lt;div class=\"parent\"&gt; &lt;p&gt;A&lt;/p&gt; &lt;div style=\"overflow: hidden;\"&gt; &lt;p&gt;B&lt;/p&gt; &lt;/div&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 相信到这里，大家已经对 BFC 有个理解了吧。下面我们就创建一个 BFC 上有关布局的应用便于加深印象 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .parent &#123; background: #ff9999; &#125; .parent .left &#123; background: #ffcc99; width: 100px; height: 100px; float: left; &#125; .parent .right &#123; background: #ffccee; height: 110px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- BFC不与float重叠 --&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 给 .right 加上 overflow: hidden 类似于清除浮动的操作，在这里就不多描述了，对清除浮动不熟悉的童鞋 请往这里走 是不是发现 BFC 元素不与 float 元素相重叠了。 好了，说了这么多，希望小伙伴们对 CSS盒模型 有个了解和认识，有讲得不对的地方希望各位童鞋多多指正，共同进步。","tags":[{"name":"css","slug":"css","permalink":"//zhoujingchao.github.io/tags/css/"}]},{"title":"Hello World","date":"2017-01-05T14:59:57.000Z","path":"2017/01/05/hello-world/","text":"在朋友的介绍下，这个博客很快就搭建起来了。 当看见它加载下来的时候，内心还是很喜悦的，有了自己的一小块领地，这种感觉很奇妙，现在想想都还有点小刺激呢。对我这种语文是体育老师教的宝宝，想想要写作，我就不自觉的在偷笑，啊哈哈 =_=好记性不如烂笔头，请打开学习旅程吧！ 当然这个色调和主题甚是喜欢啊，感谢litten大虾的神作。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"//zhoujingchao.github.io/tags/杂谈/"}]}]