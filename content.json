[{"title":"前端安全CSRF && XSS","date":"2018-04-23T09:04:56.000Z","path":"2018/04/23/前端安全CSRF&&XSS/","text":"前言 随着互联网的发达，各种WEB应用也变得越来越复杂，满足了用户的各种需求，但是随之而来的就是各种网络安全的问题。作为前端工程师的我们也逃不开这个问题。所以今天，就和大家一起聊一聊WEB前端的安全那些事儿。这里就不去说那些后端的攻击(SQL注入、DDOS攻击等)。 为什么要攻击？ 其实真正为了玩的心态去进行黑网站的人，还是少数。多数攻击还是有利益的成分在里面的。开发者不可能确保自己的应用绝对无法被攻击，但是只要攻击我们的时候，骇客花费的成本远比他可以获取的利益大得多，骇客就不会去攻击。防范强如支付宝、QQ等产品，也都曾被报过漏洞，看来防御不是绝对的，我们只能想办法让我们的应用更加安全。 前端攻击形式以及如何防范 CSRF（Cross-site request forgery），通常称为跨站请求伪造 XSS（Cross-site scripting），通常称为跨域脚本攻击 CSRF 攻击原理 如图所示，被攻击的前提就很明了了，用户需要在A网站登录过，并且网站A存在接口漏洞 CSRF 防范因此根据上述进行对症下药进行防范 Token验证 访问接口的时候，浏览器会自动上传cookie，不会上传token，所以进行token验证 Referer验证 服务器判断是否是该站点下的页面，是的话执行，反之拦截 隐藏令牌 跟token有点像，比如把验证信息隐藏在header上 XSS 攻击原理XSS 攻击是 Web 攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实施比如 SQL 注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨大的，是web安全的头号大敌。 Web 应用程序的技术基础是由 HTTP 和 HTML 组成的。HTTP 协议是 HTML 的传输机制，可使用代码设计 Web 页面布局和生成页面。如果 Web 应用程序接受用户通过 HTTP 请求（如 GET 或 POST）提交的输入信息，然后使用输出 HTML 代码在某些地方显示这些信息，便可能存在 XSS 漏洞。 实施 XSS 攻击需要具备两个条件： 需要向web页面注入恶意代码 这些恶意代码能够被浏览器成功的执行 XSS 攻击类型 反射型攻击 恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的 存储型攻击 恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上，但OA系统，和CRM系统上也能看到它身影，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，骇客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击 了解了 XSS 的原理，接下去看看怎么防范吧 XSS 防范 在表单提交或者url参数传递前，对需要的参数进行过滤 过滤用户输入的，检查用户输入的内容中是否有非法内容。如&lt;&gt;、”、 ‘、%、;、()、&amp;、+等。严格控制输出 可以利用下面这些函数对出现 xss 漏洞的参数进行过滤1、htmlspecialchars() 函数,用于转义处理在页面上显示的文本。2、htmlentities() 函数,用于转义处理在页面上显示的文本。3、strip_tags() 函数,过滤掉输入、输出里面的恶意标签。4、header() 函数,使用header(“Content-type:application/json”); 用于控制 json 数据的头部，不用于浏览。5、urlencode() 函数,用于输出处理字符型参数带入页面链接中。6、intval() 函数用于处理数值型参数输出页面中。7、自定义函数,在大多情况下，要使用一些常用的 html 标签，以美化页面显示，如留言、小纸条。那么在这样的情况下，要采用白名单的方法使用合法的标签显示，过滤掉非法的字符。","tags":[{"name":"安全","slug":"安全","permalink":"//zhoujingchao.github.io/tags/安全/"}]},{"title":"vue+vuex+vue-router+express+mongoose编写简单的todolist-demo","date":"2018-01-05T03:38:59.000Z","path":"2018/01/05/vue-vuex-vue-router-express-mongoose编写简单的todolist-demo/","text":"最近对vue和express感兴趣，趁闲暇时间，写了下前后端分离的todolist。写这篇博文来总结思考下，项目地址如下前端：https://github.com/zhoujingchao/vue-router-vuex-todolist后端：https://github.com/zhoujingchao/express-mongoose-todolist 总体概览 相信大家也看到了，实现的功能还是很简单的，整个todolist界面分为左侧导航栏和右侧内容，用户可以切换导航，可以添加任务和删除任务。补充说明下这个demo只是自己摸索vue和express过程中做出的，还是有很多不足的地方，希望大家多多指教。 前端由于这次主要是想玩下vue，就直接用了vue-cli，没有去从头开始配webpack了，想自己实现一边的童鞋们，可以参考着脚手架摸索一下。 vuex简单介绍vuex是给vue开发者提供的状态管理模式，他采用集中式存储管理应用的所用组件状态，通过action来变化。此状态自管理包含下面三个部分： state：应用数据源 view：将state映射到试图 actions：响应view导致的状态变化 这张单一的数据流示意图很好地展现了它们之间的关系 这时有过组件编写经验的童鞋就会提问，应用中多个组件共享状态时，这个单向数据流不就被破坏了？ 1.多个视图依赖同一状态2.来自不同视图的行为需要变更同一状态 问题1，传参的方式对于多层嵌套的组件将会非常繁琐并且对于兄弟组件间的状态传递也无能为力。问题2，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态。以上的这些模式都非常脆弱，通常会导致无法维护的代码。 因此vuex就是用来把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码也会变得更结构化且易维护。 附上经典图例 大致就介绍到这里了，想要深入了解的童鞋们请移步 https://vuex.vuejs.org/zh-cn/下面介绍下todolist-demo的vuex statedemo逻辑很简单，只写了一个。 123export const state = &#123; todoList: []&#125; mutationsmutations只设计状态的改变，不要在这里做异步。 12345678910111213export const mutations = &#123; getTodo (state, todo) &#123; state.todoList = todo &#125;, addTodo (state, todo) &#123; state.todoList.push(todo) &#125;, deleteTodo (state, id) &#123; state.todoList = state.todoList.filter((item) =&gt; item.id !== id) &#125;&#125; actions这里才是与后台交互，进行异步操作的地方 1234567891011121314151617181920212223242526272829303132333435import axios from 'axios'const host = 'http://localhost:9000'export const getTodo = (&#123; commit &#125;) =&gt; &#123; axios.get(`$&#123;host&#125;/todo/get`) .then(res =&gt; &#123; console.log(res) commit('getTodo', res.data.data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125;export const addTodo = (&#123; commit &#125;, data) =&gt; &#123; axios.post(`$&#123;host&#125;/todo/create`, &#123; data: data &#125;).then(res =&gt; &#123; console.log(res) commit('addTodo', data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125;export const deleteTodo = (&#123; commit &#125;, id) =&gt; &#123; axios.post(`$&#123;host&#125;/todo/delete`, &#123; id: id &#125;).then(res =&gt; &#123; console.log(res) commit('deleteTodo', id) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125; gettersdemo里没写，但是这一块主要是将store中的state派生出一些状态，用来复用 页面组件玩了一下下element-ui index.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;el-container&gt; &lt;el-header&gt;&#123;&#123; header &#125;&#125;&lt;/el-header&gt; &lt;el-container&gt; &lt;menus&gt;&lt;/menus&gt; &lt;el-container&gt; &lt;el-main&gt; &lt;router-view /&gt; &lt;/el-main&gt; &lt;el-footer&gt;&#123;&#123; footer &#125;&#125;&lt;/el-footer&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/el-container&gt;&lt;/template&gt;&lt;script&gt;import Menus from './menus'export default &#123; name: 'index', data () &#123; return &#123; header: 'header', footer: 'footer' &#125; &#125;, components: &#123; Menus &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt; .el-container &#123; height: 100%; &#125; .el-header, .el-footer &#123; background-color: #B3C0D1; color: #333; text-align: center; line-height: 60px; &#125; .el-aside &#123; background-color: #545c64; color: #333; text-align: center; line-height: 200px; &#125; .el-main &#123; background-color: #E9EEF3; color: #333; text-align: left; line-height: 50px; &#125; body &gt; .el-container &#123; margin-bottom: 40px; &#125;&lt;/style&gt; menus.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;el-aside width=\"300px\"&gt; &lt;el-menu style=\"width: 100%;\" default-active=\"2\" router class=\"el-menu-vertical-demo\" @open=\"handleOpen\" @close=\"handleClose\" background-color=\"#545c64\" text-color=\"#fff\" active-text-color=\"#ffd04b\"&gt; &lt;el-submenu index=\"1\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-location\"&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;router-link to=\"/1-1\"&gt; &lt;el-menu-item index=\"1-1\"&gt;选项1&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link to=\"/1-2\"&gt; &lt;el-menu-item index=\"1-2\"&gt;选项2&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-menu-item-group&gt; &lt;router-link to=\"/1-3\"&gt; &lt;el-menu-item index=\"1-3\"&gt;选项3&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;el-submenu index=\"1-4\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-location\"&gt;&lt;/i&gt; &lt;span&gt;选项4&lt;/span&gt; &lt;/template&gt; &lt;router-link to=\"/1-4-1\"&gt; &lt;el-menu-item index=\"1-4-1\"&gt;选项1&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;router-link to=\"/2\"&gt; &lt;el-menu-item index=\"2\"&gt; &lt;i class=\"el-icon-menu\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link to=\"/3\"&gt; &lt;el-menu-item index=\"3\"&gt; &lt;i class=\"el-icon-setting\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-menu&gt; &lt;/el-aside&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'menus', data () &#123; return &#123;&#125; &#125;, methods: &#123; handleOpen (key, keyPath) &#123; console.log(key, keyPath) &#125;, handleClose (key, keyPath) &#123; console.log(key, keyPath) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; todo.vue 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=\"todo\"&gt; &lt;el-input type=\"text\" v-model=\"taskInput\" @keyup.enter.native=\"addTask($event)\" placeholder=\"请添加任务\"&gt;&lt;/el-input&gt; &lt;div class=\"list\" v-for=\"todo in todoList\" :todo=\"todo\" :key=\"todo.id\"&gt; &lt;span&gt;&#123;&#123;todo.text&#125;&#125;&lt;/span&gt; &lt;el-button type=\"danger\" size=\"mini\" round @click.native=\"deleteTodo(todo.id)\"&gt;删除该任务&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapActions &#125; from 'vuex'export default &#123; name: 'todo', data () &#123; return &#123; taskInput: '' &#125; &#125;, created () &#123; this.getTodo() &#125;, computed: &#123; ...mapState(['todoList']) &#125;, methods: &#123; addTask (e) &#123; this.$store.dispatch('addTodo', &#123; text: this.taskInput &#125;) this.taskInput = '' &#125;, ...mapActions([ 'getTodo', 'deleteTodo' ]) &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 后端首先准备mongoose 123456789101112131415// https://www.npmjs.com/package/limboconst limbo = require('limbo')const mongoose = require('mongoose')const todoSchema = require('./todo')const url = 'mongodb://127.0.0.1:27017/vue-todo'db = limbo.use('vueTodo', &#123; conn: mongoose.createConnection(url), schemas: &#123; Todo: todoSchema &#125;&#125;)module.exports = limbo todo.js模型 123456789const mongoose = require('mongoose')const Schema = mongoose.Schemaconst todoSchema = Schema(&#123; todoList: &#123; type: Array, &#125;&#125;)module.exports = todoSchema index.js 12345678910111213141516171819202122232425262728293031323334const express = require('express')const mongoose = require('mongoose')const bodyParser = require('body-parser')const port = 9000const app = express()const todo = require('./router/todo')app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.use(bodyParser.json())// 处理跨域app.use(function(req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Methods', 'GET, PUT, POST, DELETE, OPTIONS') res.header('Access-Control-Allow-Headers', 'Origin, Content-Type, X-Requested-With, Authorization, Content-Length') if ('OPTIONS' === req.method) &#123; return res.send(200) &#125; else &#123; return next() &#125;&#125;)app.use('/todo', todo)app.listen(port, function (err) &#123; if (err) &#123; console.error(err) &#125; else &#123; console.info(\"server is running port %s\", port) &#125;&#125;) router这里_id直接从数据库里拿了这张表的id来查询了，各位大佬不用理会我这小白写法。 12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require('express')const router = express.Router()const db = require('../db')const uuidv1 = require('uuid/v1')const &#123; TodoModel&#125; = db.use('vueTodo')router.post('/create', (req, res) =&gt; &#123; const &#123; data &#125; = req.body data.id = uuidv1() const todo = &#123; todoList: data &#125; TodoModel.findOneAndUpdate(&#123; _id: '5a7026137f927103bdad780d' &#125;, &#123; $push: todo &#125;, &#123; upsert: true, new: true &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(400).json(&#123; statusCode: 400, msg: 'save todo failure' &#125;) &#125; return res.status(200).json(&#123; statusCode: 200, msg: 'save todo success' &#125;) &#125;) &#125;)router.get('/get', (req, res) =&gt; &#123; TodoModel.findOne(&#123; _id: '5a7026137f927103bdad780d' &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(400).json(&#123; statusCode: 400, msg: 'get todo failure' &#125;) &#125; return res.status(200).json(&#123; statusCode: 200, data: result &amp;&amp; result.todoList ? result.todoList : [] &#125;) &#125;)&#125;)router.post('/delete', (req, res) =&gt; &#123; const &#123; id &#125; = req.body TodoModel.findOneAndUpdate(&#123; _id: '5a7026137f927103bdad780d' &#125;, &#123; $pull: &#123; todoList: &#123; id: id &#125; &#125; &#125;, (err, result) =&gt; &#123; if (err) &#123; return res.status(400).json(&#123; statusCode: 400, msg: 'delete todo failure' &#125;) &#125; return res.status(200).json(&#123; statusCode: 200, msg: 'delete todo success' &#125;) &#125;)&#125;)module.exports = router 总结至此，demo结构已经讲的差不多了，说的不对的地方，希望各童鞋指出互相学习。不得不说，vue框架用来真的不错，大家在开发的时候，记住：要从数据的角度思考问题，一切就会变得如此简单。","tags":[{"name":"vue","slug":"vue","permalink":"//zhoujingchao.github.io/tags/vue/"}]},{"title":"深入理解Promise","date":"2017-11-07T05:32:38.000Z","path":"2017/11/07/深入理解Promise/","text":"引子这是一种普遍的获取用户信息的请求处理 12345678910111213// example 1function getUserInfo() &#123; return new Promise(function (resolve) &#123; // an asynchronous request http.get(url, function (res) &#123; resolve(res) &#125;) &#125;)&#125;getUserInfo().then(function (res) &#123; // handle&#125;) getUserInfo方法返回一个promise，可以通过它的then方法注册在promise异步操作成功时执行的回调。这种执行方式，使得异步调用变得顺手. 原理分析那么类似这种功能的Promise是怎么实现的呢？首先看一下最基础的雏形方法吧。 极简的promise雏形12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; // why array -&gt; there are a lot of callbacks sometimes this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled) &#125; function resolve(value) &#123; callbacks.forEach(function(callback) &#123; callback(value) &#125;) &#125; fn(resolve)&#125; 上面的代码逻辑大致这样: 调用then方法，将想要在Promise异步操作成功时执行回调放入callbacks队列，可以理解为注册回调函数，延伸下去向观察者模式思考 创建Promise实例时传入的函数会被赋予一个函数类型的参数，即resolve，他接受一个参数value，代表异步操作返回的结果，当异步操作执行成功 后，会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行 结合中example 1的代码来看，首先new Promise时，传给promise的函数发送异步请求，接着调用promise对象的then属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用resolve(res)方法, 该方法执行then方法注册的回调数组。 那么问题来了有同学会问，then方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用啊。so想让then方法支持链式调用，接着往下看 1234this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled) return this&#125; 只要这样就可以实现链式调用了 123456// example 2getUserInfo().then(function (res) &#123; // handle&#125;).then(function (res) &#123; // handle&#125;) 加入延时机制细心的同学应该发现，上述代码还存在一个问题：如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数： 123456789// example 3function getUserId() &#123; return new Promise(function (resolve) &#123; resolve('gg') &#125;)&#125;getUserInfo().then(function (res) &#123; // handle&#125;) 这显然是不允许的，Promises/A+规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调。我们可以这样改造下resolve函数: 1234567function resolve(value) &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value) &#125;); &#125;, 0)&#125; 上面的代码的思路大家都明白，就是通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成.那么问题又来了某些同学又发现一个问题，可以细想一下：如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的。 加入状态恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的pending、fulfilled、rejected。 Promises/A+规范中的2.1Promise States中明确规定了，pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。改进后的代码如下： 12345678910111213141516171819202122232425function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; onFulfilled(value) return &#125; function resolve(newValue) &#123; value = newValue, state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 上面的代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行。这里没有任何地方将state设为rejected，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。 链式Promise那么这里问题又来了某些同学还会问，如果用户在then函数里面注册的仍然是一个Promise，该如何解决？比如下面的example 4： 12345678910111213getUserInfo() .then(getUserDad) .then(function (res) &#123; // handle &#125;)function getUserDad(userInfoObj) &#123; return new Promise(function (resolve) &#123; http.get(url + userInfoObj.id, function (res) &#123; resolve(res) &#125;) &#125;)&#125; 这种场景相信用过promise的人都知道会有很多，那么类似这种就是所谓的链式Promise。 链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise（后邻promise）。那么我们如何衔接当前promise和后邻promise呢？接着我那会下看：只要在then方法里面return一个promise就好啦。Promises/A+规范中的2.2.7就是这么说哒😊 下面来看看这段暗藏玄机的then方法和resolve方法改造代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;) &#125;) &#125; function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; // nothing in then if(!callback.onFulfilled) &#123; callback.resolve(value) return &#125; var ret = callback.onFulfilled(value) callback.resolve(ret) &#125; function resolve (newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if (typeof then === 'function') &#123; then.call(newValue, resolve) return &#125; &#125; value = newValue, state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 下面结合example 4的代码，分析下上面的代码逻辑： example 4的then方法中，创建并返回了新的Promise实例，这是串行Promise的基础，并且支持链式调用。 handle方法是promise内部的方法。then方法传入的形参onFulfilled以及创建新Promise实例时传入的resolve均被push到当前promise的callbacks队列中，这是衔接当前promise和后邻promise的关键所在（这里一定要好好的分析下handle的作用）。 getUserInfo生成的promise异步操作成功，执行其内部方法resolve，传入的参数正是异步操作的结果即用户信息的对象userInfoObj 调用handle方法处理callbacks队列中的回调：getUserDad方法，生成新的promise（getUserDad promise） 执行之前由getUserInfo promise的then方法生成的新promise(称为bridge promise)的resolve方法，传入参数为getUserDad promise。这种情况下，会将该resolve方法传入getUserDad promise的then方法中，并直接返回。 getUserDad promise异步操作成功时，执行其callbacks中的回调：getUserInfo bridge promise中的resolve方法 最后执行getUserDad bridge promise的后邻promise的callbacks中的回调。 失败处理在异步操作失败时，标记其状态为rejected，并执行注册的失败回调: 1234567891011121314151617// example 5function getUserInfo() &#123; return new Promise(function (resolve, reject) &#123; http.get(url, function (err, res) &#123; if (err) &#123; reject(err) &#125; resolve(res) &#125;) &#125;)&#125;getUserInfo().then(function (res) &#123; // handle res&#125;, function (err) &#123; console.log(err)&#125;) 有了之前处理fulfilled状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled, onRejected) &#123; return new Promise(function (resolve, reject) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve, onRejected: onRejected || null, reject: reject &#125;) &#125;) &#125; function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; var ret, cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; ret = cb(value) callback.resolve(ret) &#125; function resolve (newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if (typeof then === 'function') &#123; then.call(newValue, resolve, reject) return &#125; &#125; value = newValue, state = 'fulfilled'; execute() &#125; function reject (reason) &#123; value = reason, state = 'rejected'; execute() &#125; execute() &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback) &#125;) &#125;, 0) &#125; fn(resolve, reject)&#125; 上面的代码增加了新的reject方法，供异步操作失败时调用，同时抽出了resolve和reject共用的部分，形成execute方法。 错误冒泡是上述代码已经支持，且非常实用的一个特性。在handle中发现没有指定异步操作失败的回调时，会直接将bridge promise(then函数返回的promise，后同)设为rejected状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的： 12345678getUserInfo() .then(getUserDad) .then(function(res) &#123; // handle res &#125; function(err) &#123; // there is something wrong in getUserInfo or getUserDad console.log(err) &#125;) 异常处理细心的同学又会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用try-catch捕获错误，并将bridge promise设为rejected状态。handle方法改造如下： 12345678910111213141516171819202122function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; var ret, cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; try &#123; ret = cb(value) callback.resolve(ret) &#125; catch(e) &#123; callback.reject(e) &#125;&#125; 如果在异步操作中，多次执行resolve或者reject会重复处理后续回调，可以通过内置一个标志位解决。 总结这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。 现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式： 通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。 被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"浏览器输入URL到页面加载的过程","date":"2017-10-13T02:45:16.000Z","path":"2017/10/13/浏览器输入URL到页面加载的过程/","text":"我们平常输入网址到页面展现这里面究竟发生了哪些事情？ 总体来说可以分为以下几个过程： DNS域名解析 TCP连接 服务器处理请求 浏览器解析 绘制页面 具体过程DNS解析DNS解析过程就是寻找哪台机器上有你需要的资源的过程。当你在浏览器中输入一个地址时，例如 www.baidu.com， 其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，由于IP地址并不方便记忆，用户更喜欢用方便记忆的网址去寻找互联网上的其他计算机，也就时上面提到的 www.baidu.com。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，此过程即是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。那么网址到IP地址转换的过程是如何进行的呢？ 解析过程DNS解析是一个递归查询的过程。 上述图片是查找www.baidu.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到baidu的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; baidu.com -&gt; www.baidu.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.baidu.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; baidu.com. -&gt; www.baidu.com.。 DNS优化了解了DNS的过程，可以为我们带来哪些？上文中请求到baidu的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。 DNS缓存DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中。 … DNS负载均衡不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。 TCP连接TCP是互联网中的传输层协议，提供可靠的链接服务，采用三次握手确认一个连接： 浏览器向服务器发送建立连接的请求。 服务器接收到浏览器发送的请求后，像浏览器发送统一连接的信号。 浏览器接受到服务器发出的同意连接的信号后，再次向服务器发出确认连接的信号。 当三次握手返程，TCP客户端和服务端成功的建立连接，就可以开始传输数据了。 服务器处理请求每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。 当web server接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如CGI脚本，JSP脚本，servlets，ASP脚本，服务器端JavaScript，或者一些其它的服务器端技术等）。 无论它们(脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。 那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照MVC设计模式进行搭建的。 处理过程如下图： 对于每一个用户输入的请求，首先被控制器接收，控制器决定用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器确定用哪个视图模型，用相应的视图格式化模型返回html字符串给浏览器，并通过显示页面呈现给用户。 浏览器解析接下来就是浏览器进行处理，通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。 加载浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。 解析解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图： css解析是指将css文件解析为样式表对象。如下图： js解析是文件在加载的同时也进行解析如果想深入如何解析的话可以看浏览器的工作原理：新式网络浏览器幕后揭秘这篇文章 渲染即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。 绘制页面浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上","tags":[{"name":"浏览器","slug":"浏览器","permalink":"//zhoujingchao.github.io/tags/浏览器/"}]},{"title":"JS原型","date":"2017-09-29T12:03:22.000Z","path":"2017/09/29/JS原型/","text":"原型1、原型是什么？js是一门基于对象的脚本语言，但他没有类的概念。js中的对象是无序属性的集合，其属性可以包含基本值，对象或者函数，类似于键值对的集合。有了对象，按理说得有继承啊，不然对象之间没有任何联系了，也就真的沦为键值对的集合了。 我们知道，在js中可以使用构造函数来创建一个新对象，像下面这样： 123456// 构造函数无返回值function Person(name) &#123; this.name = name;&#125;// 通过 new 创建一个新对象var person = new Person('Zhoujc'); new后面跟的不是类，而是构造函数。这里的构造函数可以看作是一种类型，就像面向对象编程语言中的类，但是这样创建的对象除了属性一样外，并没有其他的任何联系，对象之间无法共享属性和方法。每当我们新建一个对象时，都会分配一块新的内存，这是极大的资源浪费。考虑到这点，js的设计者Brendan Eich决定为构造函数设置一个属性。这个属性指向一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里，那些不需要共享的属性和方法，就放在构造函数里。实例对象一旦创建，将自动引用这个对象的属性和方法。也就是说实例对象的属性和方法分成两种，一种本地的，不共享的，另一种是引用的，共享的。这个就对象就是原型（prototype）对象，简称为原型。 我们通过函数声明或函数表达式创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象就是调用构造函数而创建的对象实例的原型。有一个特别的，在ECMA-262规范中，通过Function.prototype.bind创建的函数没有prototype属性。原型可以包含所有实例共享的属性和方法，也就是说只要是原型有的属性和方法，通过调用构造函数而生成的对象实例都会拥有这些属性和方法。看下面代码： 12345678910111213141516function Person(name) &#123; this.name = name;&#125;Person.prototype.age = 20;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;var person1 = new Person('Kobe');var person2 = new Person('Irving');person1.sayName(); // Kobeperson2.sayName(); // Irvingconsole.log(person1.age); // 20console.log(person2.age); // 20 这段代码我们声明了一个Person函数，并在这个函数的原型上添加了age属性和sayName方法，然后生成了两个对象实例Person1和Person2，这两个实例分别拥有自己的属性name和原型的属性age以及方法sayName。所有的实例对象共享原型对象的属性和方法，那么看起来，原型对象就像是类，我们就可以用原型来实现继承了。 2、constructor与[[Prototype]]我们知道每个函数都有一个prototype属性，指向函数的原型，因此当我们拿到一个函数的时候，就可以确定函数的原型。反之，如果给我们一个函数的原型，我们怎么知道这个原型属于哪个函数的呢？这就要说说constructor属性了： 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针 也就是说每个原型都有一个constructor属性，指向了原型所在的函数，拿前面的例子来说Person.prototype.constructor指向Person。下面是构造函数和原型的关系图： 继续，让我们说说[[prototype]]。 当我们调用构造函数创建一个新的实例之后，比如上面例子中的person1，实例的内部会包含一个指针（内部属性），指向构造函数的原型。ECMA-262第5版中管这个指针叫[[prototype]]。我们可以更新函数和原型的关系图： 不过在脚本中没有标准的方式访问[[prototype]]，但在Firefox，Safari和Chrome中可以通过__proto__属性访问。而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 在VSCode中开启调试模式，我们可以看到这些关系： 从上图中我们可以看到Person的prototype属性和person1的__proto__属性是完全一致的，Person.prototype包含了一个constructor属性，指向了Person函数。这些可以很好的印证我们上面所说的构造函数、原型、constructor以及__proto__之间的关系。 3、对象实例与原型了解完构造函数、原型、对象之间的关系后，下面我们来探讨一下对象实例和原型之间的关系。 1、判断对象实例和原型之间的关系因为我们无法直接访问实例对象的__proto__属性，所以当我们想要确定一个对象实例和某个原型之间是否存在关系时，可能会有些困难，好在我们有一些方法可以判断。我们可以通过isPrototypeOf()方法判断某个原型和对象实例是否存在关系，或者，我们也可以使用 ES5 新增的方法Object.getPrototypeOf()获取一个对象实例 __proto__属性的值。看下面的例子: 12console.log(Person.prototype.isPrototypeOf(person1)); // trueconsole.log(Object.getPrototypeOf(person1) === Person.prototype); // true 2、对象实例属性和方法的获取每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例对象中找到了具有给定名字的属性，则返回该属性的值。如果没有找到，则继续搜索__proto__指针指向的原型对象，在原型对象中查找具有给定名字的属性，如果在原型对象中找到了这个属性，则返回该属性的值。如果还找不到，就会接着查找原型的原型，直到最顶层为止。这正是多个对象实例共享原型所保存的属性和方法的基本原理。 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。我们在实例中添加的一个属性，会屏蔽原型中的同名的可写属性，如果属性是只读的，严格模式下会触发错误，非严格模式下则无法屏蔽。另外，通过hasOwnProperty方法能判断对象实例中是否存在某个属性（不能判断对象原型中是否存在该属性）。来看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142function Person() &#123; Person.prototype.name = 'Kobe'; Person.prototype.age = 18; Person.prototype.job = 'NBA player'; Person.prototype.sayName = function () &#123; console.log(this.name); &#125;;&#125;var person1 = new Person();var person2 = new Person();// 设置 phone 属性为不可写Object.defineProperty(person1, 'phone', &#123; write: false, value: '100'&#125;);// 新增一个访问器属性 addressObject.defineProperty(person1, 'address', &#123; set: function (value) &#123; console.log('set'); address = value; &#125;, get: function () &#123; return address; &#125;&#125;);// 注意，此处不能用 name，因为函数本身存在 name 属性console.log(person1.hasOwnProperty('age')); // falseconsole.log(Person.hasOwnProperty('age')); // falseperson1.name = 'Irving';console.log(person1.hasOwnProperty('name')); // trueconsole.log(person1.name); //'Irving'—来自实例console.log(person2.name); //'Kobe'—来自原型person1.phone = '123'; // 严格模式下报错person1.address = 'china'; // 调用 set 方法，输出 'set'console.log(person1.address); // 'china'console.log(person1.phone); // 100 3、in 操作符有两种方式使用 in 操作符： 单独使用 在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 for-in 循环中使用 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性， 也包括存在于原型中的属性。如果需要获取所有的属性（包括不可枚举的属性），可以使用 Object.getOwnPropertyNames() 方法。 看下面例子： 1234567891011121314151617function Person() &#123; this.name = 'Kobe'; Person.prototype.age = 18; Person.prototype.job = 'NBA player'; Person.prototype.sayName = function () &#123; console.log(this.name); &#125;;&#125;var person = new Person();for (var i in person) &#123; console.log(i); // name age job sayName &#125;console.log('name' in person); // true-来自实例console.log('age' in person); // true-来自原型 4、原型的动态性由于在对象中查找属性的过程是一次搜索，而实例与原型之间的连接只不过是一个指针，而非一个副本，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此： 12345var person = new Person();Person.prototype.sayHi = function () &#123; console.log('hi');&#125;;person.sayHi(); // hi 上面的代码中，先创建了Person的一个实例，并将其保存在person中。然后，下一条语句在Person.prototype中添加了一个方法sayHi()。即使person实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。在调用这个方法时，首先会查找person实例中是否有这个方法，发现没有，然后到person的原型对象中查找，原型中存在这个方法，查找结束。 但是下面这种代码所得到的结果就完全不一样了： 123456789101112function Person() &#123;&#125;;var person = new Person();Person.prototype = &#123; constructor: Person, name: \"kobe\", age: 18, job: \"NBA player\", sayName: function () &#123; console.log(this.name); &#125;&#125;;person.sayName(); // error 仔细观察上面的代码，我们直接用对象字面量语法给Person.prototype赋值，这似乎没有什么问题。但是我们要知道字面量语法会生成一个新的对象，也就是说这里的 Person.prototype是一个新的对象，和person的__proto__属性不再有任何关系了。此时，我们再尝试调用sayName方法就会报错，因为person的 __proto__ 属性指向的还是原来的原型对象，而原来的原型对象上并没有sayName方法，所以就会报错。 原型链1、原型的原型在前面的例子，我们是直接在原型上添加属性和方法，或者用一个新的对象赋值给原型，那么如果我们让原型对象等于另一个类型的实例，结果会怎样呢？ 123456789101112131415161718192021function Person() &#123; this.age = '18';&#125;Person.prototype.height = '198cm';function Engineer() &#123; this.work = 'Front-End';&#125;Engineer.prototype = new Person(); // 此时 Engineer.prototype 没有 constructor 属性Engineer.prototype.constructor = Engineer;Engineer.prototype.getAge = function () &#123; console.log(this.age);&#125;var person = new Person();var engineer = new Engineer();console.log(person.age); // 18Engineer.getAge(); // 18console.log(Engineer.height); // 198cmconsole.log(Engineer.prototype.__proto__ === Person.prototype); // true 在上面代码中，有两个构造函数Person和Engineer，可以看作是两个类型，Engineer的原型是Person的一个实例，也就是说Engineer的原型指向了Person的原型。 然后我们分别新建了一个Person和Engineer的实例对象，可以看到engineer实例对象能够访问到Person的 age 和 height 属性，这很好理解： Engineer的原型是Person的实例对象，Person的实例对象包含了 age 属性，而 height 属性是Person原型对象的属性，Person的实例对象自然可以访问原型中的属性，同理，Engineer的实例对象engineer也能访问Engineer原型上的属性，间接的也能访问Person原型的属性。 看起来关系有些复杂，不要紧，我们用一张图来解释这些关系： 是不是一下就很清楚了，顺着图中红色的线，engineer实例对象可以顺利的获取Person实例的属性以及Person原型的属性。至此，已经铺垫的差不多了，我们理解了原型的原型之后，也就很容易理解原型链了。 2、原型链原型链其实不难理解，上图中的红色线组成的链就可以称之为原型链，只不过这是一个不完整的原型链。我们可以这样定义原型链： 原型对象可以包含一个指向另一个原型（原型2）的指针，相应地，另一个原型（原型2）中也可以包含着一个指向对应构造函数（原型2 的构造函数）的指针。假如另一个原型（原型2）又是另一个类型（原型3 的构造函数）的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 结合上面的图，这个概念不难理解。上面的图中只有两个原型，那么当有更多的原型之后，这个红色的线理论上可以无限延伸，也就构成了原型链。 通过实现原型链，本质上扩展了前面提到过的原型搜索机制：当以读取模式访问一个实例的属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 那么原型链的末端又是什么呢？我们要知道，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。我们可以在上面代码的尾部加上一行代码进行验证： 1console.log(Person.prototype.__proto__ === Object.prototype); // true 那Object.prototype的原型又是什么呢，不可能没有终点啊？聪明的小伙伴可能已经猜到了，没错，就是null，null表示此处不应该有值，也就是终点了。我们可以在 Chrome 的控制台或 Node 中验证一下： 1console.log(Object.prototype.__proto__); // null 我们更新一下关系图 至此，一切已经很清楚了，下面我们来说说原型链的用处。 继承继承是面向对象语言中的一个很常见的概念，在阅读前面代码的过程中，我们其实已经实现了简单的继承关系，细心的小伙伴可能已经发现了。在 JavaScript 中，实现继承主要是依靠原型链来实现的。 1、原型链实现一个简单的基于原型链的继承实现看起来是这样的： 1234567891011121314151617181920function Parent() &#123; this.flag = 'parent';&#125;Parent.prototype.getFlag = function () &#123; return this.flag;&#125;function Child() &#123; this.childFlag = 'child';&#125;Child.prototype = new Parent();Child.prototype.getChildFlag = function () &#123; return this.childFlag;&#125;var instance = new Child();console.log(instance.childFlag); // childconsole.log(instance.flag); // parent 原型链虽然很强大，可以实现继承，但是会存在一些问题： 引用类型的原型属性会被所有实例共享。在通过原型链来实现继承时，引用类型的属性会被所有实例共享，一旦一个实例修改了引用类型的值，会立刻反应到其他实例上。由于基本类型不是共享的，所以彼此不会影响。 创建子类型的实例时，不能向父类型的构造函数传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给父类型的构造函数传递参数，我们传递的参数会成为所有实例的属性。 基于上面两个问题，实践中很少单独使用原型链实现继承。 2、借用构造函数为了解决上面出现的问题，出现了一种叫做借用构造函数的技术。这种技术的基本思想很简单：apply()或call()方法，在子类型构造函数的内部调用父类型的构造函数，使得子类型拥有父类型的属性和方法。 123456789101112131415161718function Parent(properties) &#123; this.properties = [].concat(properties); this.nums = [1, 2, 3, 4];&#125;function Child(properties) &#123; // 继承了 Parent，传递参数，互不影响 Parent.apply(this, properties);&#125;var instance1 = new Child(['instance1']);instance1.nums.push(5);console.log(instance1.nums); // 1,2,3,4,5console.log(instance1.properties[0]); // instance1var instance2 = new Child();console.log(instance2.nums); // 1,2,3,4console.log(instance2.properties[0]); // undefined 借用构造函数的确可以解决上面提到的两个问题，实例间不会共享属性，也可以向父类型传递参数，但是这种方法仍然存在一些问题：子类型无法继承父类型原型中的属性。我们只在子类型的构造函数中调用了父类型的构造函数，没有做其他的，子类型和父类型的原型也就没有任何联系。考虑到这个问题，借用构造函数的技术也是很少单独使用的。 3、组合继承上面两个方法能够互补彼此的不足之处，我们把这两个方法结合起来，就能比较完美的解决问题了，这就是组合继承。其背后的思路是使用原型链实现对原型属性的方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性，从而发挥两者，看一个简单的实现： 123456789101112131415161718192021222324252627function Parent(properties) &#123; this.properties = [].concat(properties); this.nums = [1, 2, 3, 4];&#125;Parent.prototype.sayProperties = function () &#123; console.log(this.properties[0]);&#125;function Child(properties) &#123; // 继承了 Parent，传递参数，互不影响 Parent.apply(this, properties);&#125;// 继承父类型的原型Child.prototype = new Parent();// isPrototypeOf() 和 instance 能正常使用Child.prototype.constructor = Child;var instance1 = new Child(['instance1']);instance1.nums.push(5);console.log(instance1.nums); // 1,2,3,4,5instance1.sayProperties(); // instance1var instance2 = new Child();console.log(instance2.nums); // 1,2,3,4instance2.sayProperties(); // undefined 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，是js中最常用的继承模式。组合继承看起来不错，但是也有它的缺点：无论什么情况下，组合继承都会调用两次父类型的构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 4、寄生组合式继承为了解决上面组合继承的问题，一种新的继承方式出现了-寄生组合继承，可以说是 JavaScript 中继承最理想的解决方案。 123456789101112131415161718192021222324252627282930// 用于继承的函数function extend(child, parent) &#123; var F = function () &#123;&#125; F.prototype = parent.prototype; child.prototype = new F(); child.prototype.constructor = child;&#125;// 父类型function Parent(name) &#123; this.name = name; this.nums = [1, 2, 3, 4];&#125;Parent.prototype.sayName = function () &#123; console.log(this.name);&#125;// 子类型function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;var parent = new Parent('baba');var child = new Child('erzi', '18');// 继承原型上的属性和方法extend(child, parent);Child.prototype.getAge = function () &#123; console.log(this.age);&#125;console.log(parent.name); // babaconsole.log(child.name); // erziconsole.log(child.getAge()); // 18 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过借用临时构造函数来继承原型。其背后的基本思路是：不必为了指定子类型的原型而调用父类型的构造函数，我们所需要的无非就是父类型原型的一个副本而已。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"数组扁平化","date":"2017-09-04T07:18:25.000Z","path":"2017/09/04/数组扁平化/","text":"扁平化数组的扁平化，就是将一个嵌套多层的 array 转换为只有一层的 array 举个 🌰 ：有个 flatten 函数做扁平化 12var arr = [1, [2, [3, 4], 5]];console.log(flatten(arr)) // [1, 2, 3, 4, 5] 递归我们最开始能想到的莫过于循环数组元素，如果还是数组，就递归调用该方法： 12345678910111213var arr = [1, [2, [3, 4], 5]];function flatten(arr) &#123; var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])); &#125; else &#123; result.push(arr[i]); &#125; &#125; return result;&#125; reduce既然是对数组做处理，最终返回值，可以考虑用 reduce 来简化代码： 12345function flatten(arr) &#123; return arr.reduce((prev, curr) =&gt; &#123; return prev.concat(Array.isArray(curr) ? flatten(curr) : curr); &#125;, [])&#125; ES6扩展运算符用于取出参数对象的所有可遍历属性，拷贝到当前对象中 12var arr = [1, [2, [3, 4], 5]];console.log([].concat(...arr)); // [1, 2, [3, 4], 5] 这种方法只可以扁平一层，所以要进行扩展 12345678var arr = [1, [2, [3, 4], 5]];function flatten(arr) &#123; while (arr.some((item) =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125;console.log(flatten(arr)); // [1, 2, 3, 4, 5] toString如果数组元素都是数字的话可以尝试： 1234567[1, [2, [3, 4], 5]].toString() // \"1,2,3,4,5\"var arr = [1, [2, [3, 4], 5]];function flatten(arr) &#123; return arr.toString().split(',').map(item =&gt; +item);&#125;console.log(flatten(arr)); // [1, 2, 3, 4, 5]","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"函数节流和防抖了解一下","date":"2017-08-30T03:28:54.000Z","path":"2017/08/30/函数节流和防抖了解一下/","text":"问题引入问题1: 实现dom拖拽功能，但是绑定在拖拽事件的时候每当元素稍微移动一点便触发了大量的毁回调函数，导致浏览器卡死。问题2: 用户连续输入时需要AJAX请求问题。 像这种场景实在是太常见了，为了应对便出现了 函数节流 和 函数防抖 这两个概念，总的来说：这两个方法是在时间轴上控制函数的执行次数。 应用场景对于函数节流（throttle）： 游戏中的刷新率 dom元素拖拽 监听滚动事件判断是否到页面底部自动加载更多内容 让一个函数不要执行得太频繁，减少一些过快的调用来节流，间隔时间段触发，有规律的执行。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;函数节流&lt;/title&gt; &lt;style&gt; body &#123; height: 4000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var time = +new Date(); function count() &#123; console.log(\"函数调用:\" + (+new Date() - time)); &#125; // 节流 控制执行间隔时间 防止频繁触发 scroll resize mousemove let throttle = (fn, delay) =&gt; &#123; let context = this, startTime = 0; return function() &#123; let curTime = new Date(); if (curTime - startTime &gt;= delay) &#123; fn.apply(context, arguments); startTime = curTime; &#125; &#125; &#125; window.onscroll = throttle(count, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 对于函数防抖（debounce）： 防止表单多次提交 防止输入框连续输入进行AJAX请求 窗口缩放 对于一定时间段的连续的函数调用，只让其执行一次，适合多次事件一次响应的情况。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;函数防抖&lt;/title&gt; &lt;style&gt; body &#123; height: 4000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onscroll = function () &#123; console.log('scroll滑动'); debounce(count, 300); &#125; function count() &#123; console.log('函数调用'); &#125; function debounce(fn, wait) &#123; let context = this; clearTimeout(fn.tId); fn.tId = setTimeout(function () &#123; fn.call(context) &#125;, wait) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们滚动页面时，频繁触发了多次的函数调用，如果函数调用中涉及到了dom操作或者接口请求的话，那就爆炸了。所以用防抖，让他停止滑动后，定时结束才执行函数处理逻辑。 总之，巧用函数节流方式能够显著得提高页面性能以及交互体验。","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"柯里化实现","date":"2017-08-14T09:31:45.000Z","path":"2017/08/14/柯里化实现/","text":"首先介绍下什么是函数柯里化。《Javascript忍者秘籍》中，对于函数柯里化的定义如下： 在一个函数中首先填充几个参数(然后再返回一个新函数)的技术称为柯里化(Currying)。 场景一实现一个加法函数： 1add(1)(2)(3,4)(5,6,7)() // 28 首先可以看到这个函数只有当参数为空时，才执行之前所有数值的加法，并且这样的嵌套可以无限进行。那么，返回值在参数不为空的时候必定返回一个函数，该函数还保存了之前的参数，这就需要闭包。 实现原理： 闭包保存args变量，存储之前的参数 新建_add函数，无参数的时候执行算法，否则存储参数到args，然后返回函数自身 1234567891011121314151617function add() &#123; // 利用闭包，不断保存arguments let args = [].slice.call(arguments); let _add = function () &#123; // 参数为空执行加法 if (arguments.length === 0) &#123; return args.reduce((a, b) =&gt; &#123; return a + b; &#125;) &#125; else &#123; // 保存参数到args，返回一个函数 [].push.apply(args, arguments); return _add &#125; &#125; return _add&#125; 场景二Dom操作中的时间绑定 1234567891011let addEvent = function(el, type, fn, capture) &#123; if (window.addEventListener) &#123; el.addEventListener(type, (e) =&gt; &#123; fn,call(el, e); &#125;, capture); &#125; else if (window.attachEvent) &#123; el.attachEvent(`on$&#123;type&#125;`, (e) =&gt; &#123; fn.call(el, e); &#125;); &#125;&#125; 这样的实现无可厚非，但是有个缺点，每次绑定都要进行一次 if-else 的操作，显然是没必要的，所以可以通过函数的柯里化改造下： 123456789101112131415let addEvent = (function() &#123; if (window.addEventListener) &#123; return function(el, type, fn, capture) &#123; el.addEventListener(type, (e) =&gt; &#123; fn.call(el, e); &#125;, capture); &#125;; &#125; else if (window.attachEvent) &#123; return function(el, type, fn, capture) &#123; el.attachEvent(`on$&#123;type&#125;`, (e) =&gt; &#123; fn.call(el, e); &#125;); &#125;; &#125;&#125;)(); 通用的函数来对普通函数进行柯里化柯里化特点很明显需要一个闭包保存参数，一个函数来进行递归，这种模式是可以通过一个包装函数，对一些基本的函数进行包装之后具有curry的特性。 1234567891011121314151617181920212223// 通用的函数柯里化构造方法function curry(func) &#123; // 第一个参数是要被柯里化的函数，需要拿掉 let args = [].slice.call(arguments, 1); // 新建_func函数作为返回 let _func = function () &#123; if (arguments.length === 0) &#123; return func.apply(this, args); &#125; else &#123; [].push.apply(args, arguments); return _func; &#125; &#125; return _func;&#125;function add() &#123; return [].reduce.call(arguments, (a, b) =&gt; &#123; return a + b; &#125;);&#125;curry(add)(1)(2,3)() 柯里化的好处 延迟计算 参数复用，当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化选择 动态创建函数","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"如何提高页面性能","date":"2017-07-23T03:13:30.000Z","path":"2017/07/23/如何提高页面性能/","text":"前言关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading是必要的。人处于“开始转移注意力”时，loading就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到loading。loading要有，但不能常有。 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议提高页面性能的方法有哪些大致可归类为以下几类： 资源压缩合并，减少HTTP请求 异步加载 利用浏览器缓存 使用CDN 预解析DNS 资源压缩合并，减少HTTP请求顾名思义即是变小资源，减少请求 异步加载1）动态脚本加载2）defer，在HTMl解析完之后才会执行，如果多个，按照加载顺序依次执行3）async，在加完之后立即执行，如果是多个，执行顺序和加载顺序无关 浏览器缓存浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。这个点是提升性能最重要的一点了，如果缺失这个，前面的资源压缩合并都起不到没什么作用了。 它又是如何判断是否使用缓存的呢？见下图： 优点有： 减少了冗余的数据传输，节省了网费 减少了服务器的负担，大大提升了网站的性能 加快了客户端加载网页的速度 缓存的分类： 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码; 协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源； 两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。 都是通过http response header中的参数来设置的 强制缓存Expires：过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。cache-control除了该字段外，还有下面几个比较常用的设置值：-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。-public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。-private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 协商缓存Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定是否命中协商缓存。 cdn加速维基百科给出的解释是： 内容分发网络（Content delivery network或Content distribution network，缩写：CDN）。简单来说它主要的工作是把我们需要被分发的内容分发到世界各地的各个节点上，让世界各地的人都可以在距离最近的网络节点拿到想要拿到的内容，减少网络传输距离从而达到加速的目的。 前端需要被加速的文件大致包括 js、css、图片、视频、和页面等文件，先聊聊js、css、图片和视频文件。这些文件和页面（html\\jsp\\aspx等）最大的区别是：这些文件都是静态的，改动较小，这类静态文件最适合做cdn加速。我们把这些静态文件通过cdn分发到全国乃至世界的各个节点，用户就可以在距离最近的边缘节点拿到所需要的内容，从而提升内容下载速度加快网页打开速度达到性能优化的目的。接下来我们聊聊页面，页面分动态页面(如：jsp等)和静态页面（html） 动态页面：当收到用户请求时服务器会在服务端对页面进行一次后台渲染把数据渲染到页面之后再返回给用户（当然，服务端也可以做缓存）。静态页面：收到用户请求时，服务端不做渲染工作直接返回给用户。 动态页面是不适合做cdn加速的。原因：由于页面是动态的，内容的有效期就比较活跃。假如我们对动态页面做了cdn加速，那么场景应该是这样的：用户——&gt;边缘节点（验证有效期发现失效）——&gt;源站。经过这个过程才能拿到页面，这样并没有起到加速的作用反而更慢了，那我们还不如直接去源站拿。 预解析DNSDNS解析时间可能导致大量用户感知延迟，DNS解析所需的时间差异非常大，延迟范围可以从1ms（本地缓存结果）到普遍的几秒钟时间。所以利用DNS预解析是有意义的。 浏览器对网站第一次的域名DNS解析查找流程依次为：浏览器缓存-系统缓存-路由器缓存-ISP DNS缓存-递归搜索 实现方式： 用meta信息来告知浏览器, 当前页面要做DNS预解析: &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; 在页面header中使用link标签来强制对DNS预解析: &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt; 注：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。","tags":[{"name":"性能","slug":"性能","permalink":"//zhoujingchao.github.io/tags/性能/"}]},{"title":"移动端webApp踩坑之记","date":"2017-07-06T15:32:02.000Z","path":"2017/07/06/移动端webApp踩坑之记/","text":"记录一下第一次开发hybrid app，遇到的一些坑。 一、H5与Native交互由于初期项目比较急，没有仔细考虑jsbridge技术。 ios直接很粗暴的通过协议 localtion.href = jsbridge://methodName?param1=value1&amp;param2=value2 来解决问题 android就让原生提供一个Android的类，是暴露在window下来调用的 然后就balabalabala…开始爬坑咦，这什么鬼？怎么我连续多次发起location.href的协议，ios只能接收到最后一次请求？妈蛋，那我就不连续发咯。怎么我在路由跳转的时候做些协议会偶尔不起作用，ios接收不到？强行添加123setTimeout(function() &#123; localtion.href = 'jsbridge://methodName?param1=value1&amp;param2=value2';&#125;, 0); wtf？？？ 想想就不对劲呢，\b后面利用业余时间查找了下jsbridge相关资料，才恍然大悟。原来js调用oc或swift有3两种方式： 通过 localtion.href 通过 iframe 方式； ios7新加的 JavaScriptCore 参考链接，提供一个类供js直接调用 通过location.href有个问题，就是如果我们连续多次修改window.location.href的值，在Native层只能接收到最后一次请求，前面的请求都会被忽略掉，不推荐使用。 js调用java： 通过schema方式，使用shouldOverrideUrlLoading方法对url协议进行解析。这种js的调用方式与ios的一样，使用iframe来调用native代码。完整的URL Scheme协议格式：xl://goods:8888/goodsDetail?goodsId=10011002通过上面的路径 Scheme、Host、port、path、query全部包含，基本上平时使用路径就是这样子的。xl代表该Scheme 协议名称goods代表Scheme作用于哪个地址域goodsDetail代表Scheme指定的页面goodsId代表传递的参数8888代表该路径的端口号 提供一个类给js直接调用 简单示例iframe封装： 123456789101112/** * @param &#123;string&#125; fname */export function postWebviewData(fname) &#123; let wvIframe = document.createElement(‘iframe’); wvIframe.style.display = ‘none’; waiframe.src = `jsbridge://$&#123;fname&#125;?param1=value1&amp;param2=value2`; document.body.appendChild(wvIframe); setTimeout(function() &#123; document.body.removeChild(wvIframe); &#125;, 0);&#125; 具体协议和native商量如何传参，再进行封装就好，然后就能快乐的玩耍了辣。其实我还是建议童鞋们，把ios和android都统一起来用同一种方式。 二、WebView 性能优化1. WebView的启动到js解析，编译，执行，消耗的时间比较久，然后呈现在眼前就是这么几个状态： 交互无反馈 到达新的页面，页面白屏 页面基本框架出现，但是没有数据；页面处于loading状态 最后出现所需的数据 解决思路： h5做的是单页面，所以h5首先做了按需加载，接着WebView也做了按需加载，这样就快很多了，时间大概在1-2s， 刚启动的时候就补了个动画页弥补这1-2s的加载 原生和h5都需要做本地缓存使页面和图片呈现的更快，再做数据请求更新 2. 点击延迟在WebView中，click通常会有大约300ms的延迟（包括链接的点击，表单的提交，控件的交互等任何用户点击行为）。 解决思路参考链接: fastclick 三、在ios中，输入状态时，h5定位属性fixed失效```12345678910111213141516171819&lt;div&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header class=\"header\"&gt; 我是头部 &lt;/header&gt; &lt;!-- 可以滚动的区域 --&gt; &lt;main class=\"main\"&gt; &lt;!-- 内容在这里... --&gt; &lt;/main&gt; &lt;!-- fixed定位的底部 --&gt; &lt;footer class=\"footer\"&gt; &lt;div class=\"textarea needsclick\" contentEditable=\"true\" suppressContentEditableWarning&gt;&lt;/div&gt; &lt;button onclick=\"handleClick()\"&gt;发送&lt;/button&gt; &lt;/footer&gt;&lt;/div&gt; 网上也查得到相关解决方案比如：http://efe.baidu.com/blog/mobile-fixed-layout/但是我也不知道为什么我按这个思路来，还是解决不了这个问题，有些人说可以解决，有些人说解决不了，就是这么的奇葩，或许是我姿势不对吧。=_=!! so，还是自己尝试摸索解决，我的布局header和footer是fixed，中间可滚动的区域是relative，算了不说了，直接上代码吧。12345678910111213141516171819202122// listenFocus和listenBlur是给可编辑div添加的聚焦和失焦的事件监听listenFocus = () =&gt; &#123; if (isiOS) &#123; let clientHeight = document.querySelector('.main').clientHeight // 高保真给的是2x的图，头部和底部的高度都是100px，所以中间的可视高度如下 let availHeight = (clientHeight - 200) / 2 // 此定位解决方案，当内容达不到滚动时，输入框就会移动，所以判断下内容高度是否达到滚动条件 if (availHeight &gt; window.screen.availHeight) &#123; // 巨坑啊！fuck this！fixed属性失效，千辛万苦摸索定位解决 document.querySelector('.footer').style.position = 'relative' document.querySelector('.main').style.paddingBottom = '0' &#125; // 原生键盘弹起后, 操作时高度会不一样，使输入框始终不会被键盘遮挡 timerId = setInterval(function() &#123; document.body.scrollTop = document.body.scrollHeight &#125;, 100) &#125;&#125; listenBlur = () =&gt; &#123; if (isiOS) &#123; clearInterval(timerId) &#125; 建议移动端用flex布局 四、在ios中，h5底部输入框被原生键盘遮挡问题参考链接 https://segmentfault.com/a/1190000006243816项目中解决代码123456789/** * 原生键盘弹起后, 操作时高度会不一样，使输入框始终不会被键盘遮挡 */ timeoutToInterval = () =&gt; &#123; this.timerId = setTimeout(() =&gt; &#123; document.body.scrollTop = document.body.scrollHeight this.timeoutToInterval() &#125;, 100)&#125; 五、ios系统11以上，如果有原生底部栏的话，底部就会被抬高具体操作是原生scrollView里的contentInsetAdjustmentBehavior导致的下面是oc代码：12345if (version &gt; 11) &#123; self.webview.scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125;else&#123; self.automaticallyAdjustsScrollViewInsets = NO;&#125;","tags":[{"name":"移动端","slug":"移动端","permalink":"//zhoujingchao.github.io/tags/移动端/"}]},{"title":"一道经典的js面试题","date":"2017-03-24T02:08:51.000Z","path":"2017/03/24/一道经典的js面试题/","text":"废话不多说，直切主题 1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); 输出？ 123456Wed Jan 24 2018 10:13:53 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5Wed Jan 24 2018 10:13:54 GMT+0800 (CST) 5 循环执行过程中，几乎同时设置了5个定时器，这些定时器一般情况下都会在1秒之后触发，而循环完的输出是立即执行的。所以先输出了5，1秒之后输出5个5。这里考查了js异步代码，变量作用域，定时器工作机制的理解。 如果期望代码输出：5 -&gt; 0,1,2,3,4，该怎么改造？熟悉闭包的同学很快能给出下面的解决方案： 123456789for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(new Date, j); &#125;, 1000); &#125;)(i);&#125;console.log(new Date, i); 这里利用了立即执行函数的表达式来解决闭包，当然还可以利用js中基本类型的参数是按值传递的特征来改造： 1234567891011var output = function (i) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 5; i++) &#123; output(i);&#125;console.log(new Date, i); 接着还可以衍生出ES6的考察： 1234567for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); 这里只有个非常细微的变动，即使用 ES6 块级作用域 中的 let 替代了 var，但是代码在实际运行时第二段 console.log(new Date, i) 会报错，因为最后那个输出使用的 i 在其所在的作用域中并不存在，i 只存在于循环内部。 下面再进行扩展要求循环和两处 console 不变，要求代码执行时立即输出0，之后每隔1秒依次输出1，2，3，4，循环结束后，大概在第5秒输出5 12345678910111213141516171819202122232425let tasks = [];// let output = (i) =&gt; new Promise(resolve =&gt; &#123;// setTimeout(() =&gt; &#123;// console.log(new Date, i);// resolve();// &#125;, 1000 * i);// &#125;)for (var i = 0; i &lt; 5; i++) &#123; // tasks.push(output(i)); ((j) =&gt; &#123; tasks.push(new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, j); resolve(); &#125;, 1000 * j); &#125;)); &#125;)(i);&#125;Promise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000);&#125;); 既然到 Promise 了，那我们是不是应该用下 ES7 中的 async await 特性来实现一下下呢。 12345678910111213const asyncFn = (time) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, time);&#125;); // 这个分号必须写，不然下面的立即表达式会融合到setTimeout函数中，如果使用大括号return new promise使之闭合，就不会有这个问题了(async () =&gt; &#123; for (var i = 0; i &lt; 5; i++) &#123; await asyncFn(1000); console.log(new Date, i); &#125; await asyncFn(1000); console.log(new Date, i);&#125;)();","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"JS基本面试题","date":"2017-03-13T07:32:31.000Z","path":"2017/03/13/JS基本面试题/","text":"1、typeof a === ‘object’ 来确定a是否是对象的问题?在js中，null这个数据类型也被认为是对象 12let a = nullconsole.log(typeof a === 'object') // true 2、下面代码控制台输出什么，为什么？12345(function()&#123; let a = b = 3&#125;)()console.log(\"a: \" + (typeof a !== 'undefined'))console.log(\"b: \" + (typeof b !== 'undefined')) 大部分开发人员会理解成 12let b = 3let a = b 事实上是 12b = 3let a = b 所以你不使用严格模式的话，该代码输出 12a: falseb: true use strict下，就会报error，ReferenceError: b is not defined 3、下面代码控制台输出什么，为什么？12345678910111213let obj = &#123; a: 'a', func: function() &#123; var _this = this console.log(\"outer func: this.a = \" + this.a) console.log(\"outer func: _this.a = \" + _this.a) (function() &#123; console.log(\"inner func: this.a = \" + this.a) console.log(\"inner func: _this.a = \" + _this.a) &#125;()) &#125;&#125;obj.func() 输出结果如下： 1234outer func: this.a = aouter func: _this.a = ainner func: this.a = undefinedinner func: _this.a = a 在outer函数中，this和_this都指向了obj，所以能正确引用，在inner函数中，this的指向是window，_this的指向还是obj。 4、封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？这是必须这么做的，现在的js库实在是太多了并且还会越来越多，像这样创建的闭包，就是创建了一个私有的命名空间，从而避免模块与库之间的命名冲突。特点是，允许一个易于引用的别名用于全局变量，例如 1(function(yourSymbol) &#123; /* yourPluginName plugin code */ &#125; )(yourPluginName) 5、在JavaScript源文件的开头包含 ‘use strict’ 有什么意义和好处？use strict 是一种在js代码运行时自动实行更严格解析和错误处理的方法。优点： 使调试更加容易，那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。在严格模式下，引用 null或未定义的 this 值会抛出错误。 不允许重复的属性名称或参数值。当检测到对象（例如，var obj = {foo: “bar”, foo: “baz”}）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。 在delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。 6、以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？12345678910111213function fn1() &#123; return &#123; dog: 'hello' &#125;&#125;function fn2() &#123; return &#123; dog: 'hello' &#125;&#125;console.log(fn1())console.log(fn2()) 结果如下： 12&#123;dog: \"hello\"&#125;undefined 原因是在js中，return语句的代码行\b后面没有其他代码的时候，分号会自动插入到返回语句之后，因此也不会抛出错误，fn2()里return下面的代码就是一个未使用得代码块。 7、下列代码输出什么？为什么？12console.log(0.1 + 0.2)console.log(0.1 + 0.2 == 0.3) 本题考查的是js中浮点数的计算精度问题先看下输出 120.30000000000000004false 这不是语言的bug或者宿主环境的bug。目前所有的程序设计语言在对浮点数进行四则运算时，都会涉及到浮点数精确度的问题。我们知道在计算机的世界中，计算机只认识0，1，我们传入的十进制数字并不会被计算机直接识别。计算机会先将其转换成二进制，然后使用转换后的二进制进行计算。那么0.1和0.2转换成二进制分别是， (0.1) =&gt; 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101 (0.2) =&gt; 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 01 然后对上面的两个二进制数字做加法，得到的结果是， 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 01 再把这个二进制转换成十进制，就是我们前面的结果0.30000000000000004了。 8、 下列代码行1-4如何排序，为什么？123456(function() &#123; console.log(1) setTimeout(function()&#123;console.log(2)&#125;, 1000) setTimeout(function()&#123;console.log(3)&#125;, 0) console.log(4)&#125;)() 结果如下： 12341432 \bsetTimeout() 会把其引用的函数的执行放到事件队列中，当它的第二个参数为0时，意思是尽快执行指定的函数，具体而言，函数的执行会放置在事件队列的下一个计时器开始，但是请注意，这不是立即执行，函数不会被执行除非下一个计时器开始。这就是为什么在上述的例子中，用 console.log(4) 发生在调用 console.log(3) 之前（因为调用 console.log(3) 是通过setTimeout被调用的，因此会稍微延迟） 9、写一个简单的函数（越简洁越好），要求返回一个布尔值指明字符串是否为回文结构。123456\bfunction isPalindrome(str) &#123; // 排除\b非单词字符 str = str.replace(/W/g, '').toLowerCaxe() str.split('').reverse().join('') return str&#125; 10、写一个add方法，下面的调用，都能正常输出12console.log(add(2, 3)) //5console.log(add(2)(3)) //5 123456789function add(x, y) &#123; if (y) &#123; return x + y &#125; else &#123; return function(y) &#123; return x + y &#125; &#125;&#125; 11、\b请看下面代码片段12345678for (var i = 0; i &lt; 5; i++) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode('button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125; 1)当用户点击\bbutton4的时候会输出什么到控制台，为什么？ 无论点击哪个按钮，数字5将总会输出到控制台。这是因为，当 onclick 方法被调用（对于任何按钮）的时候， for 循环已经结束，变量 i 已经获得了5的值 2）提供一个或多个备用的可按预期工作的实现方案。 要让代码工作的关键是，通过传递到一个新创建的函数对象，在每次传递通过 for 循环时，捕捉到 i 值。下面是三种可能实现的方法： 12345btn.addEventListener('click', (function(i) &#123; return function() &#123; console.log(i) &#125;&#125;)(i)) 12345(function(i) &#123; brn.addEventListener('click', function() &#123; console.log(i) &#125;)&#125;)(i) 123456['a', 'b', 'c', 'd', 'e'].forEach(function (value, i) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode('button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125;); 12、下面的代码输出什么到控制台，为什么？123456let arr1 = 'john'.split('')let arr2 = arr1.reverse()let arr3 = 'jones'.split('')arr2.push(arr3)console.log('arr1.length: ' + arr1.length + ' last=' + arr1.slice(-1))console.log('arr2.length: ' + arr2.length + ' last=' + arr2.slice(-1)) 结果如下： 12arr1.length: last=j,o,n,e,sarr2.length: last=j,o,n,e,s \barr1和arr2执行完后，两者相同，原因如下： 调用数组对象的 reverse() 方法并不只返回反顺序的阵列，它也反转了数组本身的顺序 reverse() 方法返回一个到数组本身的引用（在这种情况下即，arr1）。其结果为，arr2 仅仅是一个到 arr1的引用（而不是副本）。因此，当对 arr2做了任何事情（即当我们调用 arr2.push(arr3);）时，arr1 也会受到影响，因为 arr1 和 arr2 引用的是同一个对象。 13、下面的代码输出什么到控制台？为什么？123456console.log(1 + '2' + '2')console.log(1 + +'2' + '2')console.log(1 + -'1' + '2')console.log(+'1' + '1' + '2')console.log( 'A' - 'B' + '2')console.log( 'A' - 'B' + 2) 结果如下： 123456\b1223202112NaN2NaN","tags":[{"name":"js","slug":"js","permalink":"//zhoujingchao.github.io/tags/js/"}]},{"title":"CSS盒模型的认识","date":"2017-02-21T07:21:37.000Z","path":"2017/02/21/CSS盒模型的认识/","text":"前言CSS是前端工程师绕不开的话题，呈现在人们眼前的网页布局，可都离不开它的功劳。 今天我们就来探讨一下对CSS盒模型的认识。 何为CSS盒模型网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 基本概念浏览器解析CSS有两种模式：标准模式(strict mode) 和 怪异模式(quirks mode)。因此就产生了两种盒模型 标准盒模型 和 IE盒模型。 标准模式：浏览器按W3C标准解析执行代码。示意图如下： 怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。示意图如下： 浏览器解析时使用标准模式还是怪异模式，与网页中的DTD（Document Type Defination）声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相关的方式加载网页并显示，忽略DTD声明，将使网页进入怪异模式。 当然也可以通过css来设置盒模型：box-sizing: content-box;box-sizing: border-box;前者就是标准模型，后者是IE模型。 JS如何获取盒模型的宽和高dom为html里获取到的节点 dom.style.width/height，通过dom节点的style属性拿到 dom.currentStyle.width/height，浏览器渲染后的宽高，仅IE支持 window.getComputedStyle(dom).width/height，原理同第二条，兼容第二种写法 dom.getBoundingClientRect().width/height，用与计算元素的绝对位置，也能拿到宽高 盒模型的边距重叠 假如这里有两个元素，子元素高度100px，margin-top为10px，那么它的父元素高度是多少呢？这里我暂时先不给答案，后面再给。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .parent &#123; background: #ff9999; &#125; .child &#123; background: #ffcc99; height: 100px; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到父元素是100px，是吧，嗯，没毛病。接着在父元素parent上加上 overflow: hidden 属性我们再看看效果 父元素是不是变成110px了，嗯？，你接着说，我在听…这是为什么呢？其实给父级加了 overflow: hidden 即给这个元素创建了 BFC。 BFC那么什么是 BFC 呢？BFC 即 Block Formatting Contexts (块级格式化上下文)具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .parent &#123; background: #ff9999; overflow: hidden; &#125; .parent &gt; p &#123; background: #ffcc99; margin: 5px auto 20px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- BFC垂直方向边距重叠 --&gt; &lt;div class=\"parent\"&gt; &lt;p&gt;A&lt;/p&gt; &lt;p&gt;B&lt;/p&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 是不是可以发现 B 的上边距和 A 的下边距发生了重叠，按照重叠原则会取最大的像素即时如上20px。那么要如何解决这个呢，不让他们重叠，那就是给元素创建 BFC。 12345678910&lt;body&gt; &lt;!-- BFC垂直方向边距重叠 --&gt; &lt;div class=\"parent\"&gt; &lt;p&gt;A&lt;/p&gt; &lt;div style=\"overflow: hidden;\"&gt; &lt;p&gt;B&lt;/p&gt; &lt;/div&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 相信到这里，大家已经对 BFC 有个理解了吧。下面我们就创建一个 BFC 上有关布局的应用便于加深印象 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .parent &#123; background: #ff9999; &#125; .parent .left &#123; background: #ffcc99; width: 100px; height: 100px; float: left; &#125; .parent .right &#123; background: #ffccee; height: 110px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- BFC不与float重叠 --&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 给 .right 加上 overflow: hidden 类似于清除浮动的操作，在这里就不多描述了，对清除浮动不熟悉的童鞋 请往这里走 是不是发现 BFC 元素不与 float 元素相重叠了。 好了，说了这么多，希望小伙伴们对 CSS盒模型 有个了解和认识，有讲得不对的地方希望各位童鞋多多指正，共同进步。","tags":[{"name":"css","slug":"css","permalink":"//zhoujingchao.github.io/tags/css/"}]},{"title":"Hello World","date":"2017-01-05T14:59:57.000Z","path":"2017/01/05/hello-world/","text":"在朋友的介绍下，这个博客很快就搭建起来了。 当看见它加载下来的时候，内心还是很喜悦的，有了自己的一小块领地，这种感觉很奇妙，现在想想都还有点小刺激呢。对我这种语文是体育老师教的宝宝，想想要写作，我就不自觉的在偷笑，啊哈哈 =_=好记性不如烂笔头，请打开学习旅程吧！ 当然这个色调和主题甚是喜欢啊，感谢litten大虾的神作。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"//zhoujingchao.github.io/tags/杂谈/"}]}]