[{"title":"深入理解Promise","date":"2018-01-07T05:32:38.000Z","path":"2018/01/07/深入理解Promise/","text":"前言本着对Promise内部的一些好奇，趁工作闲暇，分析分析promise的这种规则机制是如何实现的。 本文的promise源码是按照Promise/A+规范来编写的 引子下面一步一步跟着思路走吧 这是一种普遍的获取用户信息的请求处理12345678910111213// example 1function getUserInfo() &#123; return new Promise(function (resolve) &#123; // an asynchronous request http.get(url, function (res) &#123; resolve(res) &#125;) &#125;)&#125;getUserInfo().then(function (res) &#123; // handle&#125;) getUserInfo方法返回一个promise，可以通过它的then方法注册在promise异步操作成功时执行的回调。这种执行方式，使得异步调用变得顺手. 原理分析那么类似这种功能的Promise是怎么实现的呢？首先看一下最基础的雏形方法吧。 极简的promise雏形12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; // why array -&gt; there are a lot of callbacks sometimes this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled) &#125; function resolve(value) &#123; callbacks.forEach(function(callback) &#123; callback(value) &#125;) &#125; fn(resolve)&#125; 上面的代码逻辑大致这样: 调用then方法，将想要在Promise异步操作成功时执行回调放入callbacks队列，可以理解为注册回调函数，延伸下去向观察者模式思考 创建Promise实例时传入的函数会被赋予一个函数类型的参数，即resolve，他接受一个参数value，代表异步操作返回的结果，当异步操作执行成功后，会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行结合中example 1的代码来看，首先new Promise时，传给promise的函数发送异步请求，接着调用promise对象的then属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用resolve(res)方法, 该方法执行then方法注册的回调数组。 那么问题来了有同学会问，then方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用啊。so想让then方法支持链式调用，接着往下看1234this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled) return this&#125; 只要这样就可以实现链式调用了123456// example 2getUserInfo().then(function (res) &#123; // handle&#125;).then(function (res) &#123; // handle&#125;) 加入延时机制细心的同学应该发现，上述代码还存在一个问题：如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数：123456789// example 3function getUserId() &#123; return new Promise(function (resolve) &#123; resolve('gg') &#125;)&#125;getUserInfo().then(function (res) &#123; // handle&#125;) 这显然是不允许的，Promises/A+规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调。我们可以这样改造下resolve函数:1234567function resolve(value) &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value) &#125;); &#125;, 0)&#125; 上面的代码的思路大家都明白，就是通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成.那么问题又来了某些同学又发现一个问题，可以细想一下：如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的。 加入状态恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的pending、fulfilled、rejected。 Promises/A+规范中的2.1Promise States中明确规定了，pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。改进后的代码如下：12345678910111213141516171819202122232425function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; onFulfilled(value) return &#125; function resolve(newValue) &#123; value = newValue, state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 上面的代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行。这里没有任何地方将state设为rejected，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。 链式Promise那么这里问题又来了某些同学还会问，如果用户在then函数里面注册的仍然是一个Promise，该如何解决？比如下面的example 4：12345678910111213getUserInfo() .then(getUserDad) .then(function (res) &#123; // handle &#125;)function getUserDad(userInfoObj) &#123; return new Promise(function (resolve) &#123; http.get(url + userInfoObj.id, function (res) &#123; resolve(res) &#125;) &#125;)&#125; 这种场景相信用过promise的人都知道会有很多，那么类似这种就是所谓的链式Promise。 链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise（后邻promise）。那么我们如何衔接当前promise和后邻promise呢？接着我那会下看：只要在then方法里面return一个promise就好啦。Promises/A+规范中的2.2.7就是这么说哒😊 下面来看看这段暗藏玄机的then方法和resolve方法改造代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;) &#125;) &#125; function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; // nothing in then if(!callback.onFulfilled) &#123; callback.resolve(value) return &#125; var ret = callback.onFulfilled(value) callback.resolve(ret) &#125; function resolve (newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if (typeof then === 'function') &#123; then.call(newValue, resolve) return &#125; &#125; value = newValue, state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback) &#125;) &#125;, 0) &#125; fn(resolve)&#125; 下面结合example 4的代码，分析下上面的代码逻辑： example 4的then方法中，创建并返回了新的Promise实例，这是串行Promise的基础，并且支持链式调用。 handle方法是promise内部的方法。then方法传入的形参onFulfilled以及创建新Promise实例时传入的resolve均被push到当前promise的callbacks队列中，这是衔接当前promise和后邻promise的关键所在（这里一定要好好的分析下handle的作用）。 getUserInfo生成的promise异步操作成功，执行其内部方法resolve，传入的参数正是异步操作的结果即用户信息的对象userInfoObj 调用handle方法处理callbacks队列中的回调：getUserDad方法，生成新的promise（getUserDad promise） 执行之前由getUserInfo promise的then方法生成的新promise(称为bridge promise)的resolve方法，传入参数为getUserDad promise。这种情况下，会将该resolve方法传入getUserDad promise的then方法中，并直接返回。 getUserDad promise异步操作成功时，执行其callbacks中的回调：getUserInfo bridge promise中的resolve方法 最后执行getUserDad bridge promise的后邻promise的callbacks中的回调。失败处理在异步操作失败时，标记其状态为rejected，并执行注册的失败回调:1234567891011121314151617// example 5function getUserInfo() &#123; return new Promise(function (resolve, reject) &#123; http.get(url, function (err, res) &#123; if (err) &#123; reject(err) &#125; resolve(res) &#125;) &#125;)&#125;getUserInfo().then(function (res) &#123; // handle res&#125;, function (err) &#123; console.log(err)&#125;) 有了之前处理fulfilled状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Promise(fn) &#123; var state = 'pendding', value = null, callbacks = []; this.then = function (onFulfilled, onRejected) &#123; return new Promise(function (resolve, reject) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve, onRejected: onRejected || null, reject: reject &#125;) &#125;) &#125; function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; var ret, cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; ret = cb(value) callback.resolve(ret) &#125; function resolve (newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if (typeof then === 'function') &#123; then.call(newValue, resolve, reject) return &#125; &#125; value = newValue, state = 'fulfilled'; execute() &#125; function reject (reason) &#123; value = reason, state = 'rejected'; execute() &#125; execute() &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback) &#125;) &#125;, 0) &#125; fn(resolve, reject)&#125; 上面的代码增加了新的reject方法，供异步操作失败时调用，同时抽出了resolve和reject共用的部分，形成execute方法。 错误冒泡是上述代码已经支持，且非常实用的一个特性。在handle中发现没有指定异步操作失败的回调时，会直接将bridge promise(then函数返回的promise，后同)设为rejected状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：12345678getUserInfo() .then(getUserDad) .then(function(res) &#123; // handle res &#125; function(err) &#123; // there is something wrong in getUserInfo or getUserDad console.log(err) &#125;) 异常处理细心的同学又会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用try-catch捕获错误，并将bridge promise设为rejected状态。handle方法改造如下：12345678910111213141516171819202122function handle(callback) &#123; if (state === 'pendding') &#123; callbacks.push(onFulfilled) return this &#125; var ret, cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; try &#123; ret = cb(value) callback.resolve(ret) &#125; catch(e) &#123; callback.reject(e) &#125;&#125; 如果在异步操作中，多次执行resolve或者reject会重复处理后续回调，可以通过内置一个标志位解决。 总结刚开始看promise源码的时候总不能很好的理解then和resolve函数的运行机理，但是如果你静下心来，反过来根据执行promise时的逻辑来推演，就不难理解了。这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。 现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式： 通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。 被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。参考文献https://github.com/git-lt/MPromise","tags":[]},{"title":"JS基本面试题","date":"2017-09-13T07:32:31.000Z","path":"2017/09/13/JS基本面试题/","text":"1、typeof a === ‘object’ 来确定a是否是对象的问题?在js中，null这个数据类型也被认为是对象12let a = nullconsole.log(typeof a === 'object') // true 2、下面代码控制台输出什么，为什么？12345(function()&#123; let a = b = 3&#125;)()console.log(\"a: \" + (typeof a !== 'undefined'))console.log(\"b: \" + (typeof b !== 'undefined')) 大部分开发人员会理解成12let b = 3let a = b 事实上是12b = 3let a = b 所以你不使用严格模式的话，该代码输出12a: falseb: true use strict下，就会报error，ReferenceError: b is not defined 3、下面代码控制台输出什么，为什么？12345678910111213let obj = &#123; a: 'a', func: function() &#123; var _this = this console.log(\"outer func: this.a = \" + this.a) console.log(\"outer func: _this.a = \" + _this.a) (function() &#123; console.log(\"inner func: this.a = \" + this.a) console.log(\"inner func: _this.a = \" + _this.a) &#125;()) &#125;&#125;obj.func() 输出结果如下：1234outer func: this.a = aouter func: _this.a = ainner func: this.a = undefinedinner func: _this.a = a 在outer函数中，this和_this都指向了obj，所以能正确引用，在inner函数中，this的指向是window，_this的指向还是obj。 4、封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？这是必须这么做的，现在的js库实在是太多了并且还会越来越多，像这样创建的闭包，就是创建了一个私有的命名空间，从而避免模块与库之间的命名冲突。特点是，允许一个易于引用的别名用于全局变量，例如1(function(yourSymbol) &#123; /* yourPluginName plugin code */ &#125; )(yourPluginName) 5、在JavaScript源文件的开头包含 ‘use strict’ 有什么意义和好处？use strict 是一种在js代码运行时自动实行更严格解析和错误处理的方法。优点： 使调试更加容易，那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。在严格模式下，引用 null或未定义的 this 值会抛出错误。 不允许重复的属性名称或参数值。当检测到对象（例如，var obj = {foo: “bar”, foo: “baz”}）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。 在delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。 6、以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？12345678910111213function fn1() &#123; return &#123; dog: 'hello' &#125;&#125;function fn2() &#123; return &#123; dog: 'hello' &#125;&#125;console.log(fn1())console.log(fn2()) 结果如下：12&#123;dog: \"hello\"&#125;undefined 原因是在js中，return语句的代码行\b后面没有其他代码的时候，分号会自动插入到返回语句之后，因此也不会抛出错误，fn2()里return下面的代码就是一个未使用得代码块。 7、下列代码输出什么？为什么？12console.log(0.1 + 0.2)console.log(0.1 + 0.2 == 0.3) 本题考查的是js中浮点数的计算精度问题先看下输出120.30000000000000004false 这不是语言的bug或者宿主环境的bug。目前所有的程序设计语言在对浮点数进行四则运算时，都会涉及到浮点数精确度的问题。我们知道在计算机的世界中，计算机只认识0，1，我们传入的十进制数字并不会被计算机直接识别。计算机会先将其转换成二进制，然后使用转换后的二进制进行计算。那么0.1和0.2转换成二进制分别是， (0.1) =&gt; 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101 (0.2) =&gt; 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 01 然后对上面的两个二进制数字做加法，得到的结果是， 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 01 再把这个二进制转换成十进制，就是我们前面的结果0.30000000000000004了。 8、 下列代码行1-4如何排序，为什么？123456(function() &#123; console.log(1) setTimeout(function()&#123;console.log(2)&#125;, 1000) setTimeout(function()&#123;console.log(3)&#125;, 0) console.log(4)&#125;)() 结果如下：12341432 \bsetTimeout() 会把其引用的函数的执行放到事件队列中，当它的第二个参数为0时，意思是尽快执行指定的函数，具体而言，函数的执行会放置在事件队列的下一个计时器开始，但是请注意，这不是立即执行，函数不会被执行除非下一个计时器开始。这就是为什么在上述的例子中，用 console.log(4) 发生在调用 console.log(3) 之前（因为调用 console.log(3) 是通过setTimeout被调用的，因此会稍微延迟） 9、写一个简单的函数（越简洁越好），要求返回一个布尔值指明字符串是否为回文结构。123456\bfunction isPalindrome(str) &#123; // 排除\b非单词字符 str = str.replace(/W/g, '').toLowerCaxe() str.split('').reverse().join('') return str&#125; 10、写一个add方法，下面的调用，都能正常输出12console.log(add(2, 3)) //5console.log(add(2)(3)) //5 123456789function add(x, y) &#123; if (y) &#123; return x + y &#125; else &#123; return function(y) &#123; return x + y &#125; &#125;&#125; 11、\b请看下面代码片段12345678for (var i = 0; i &lt; 5; i++) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode('button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125; 1)当用户点击\bbutton4的时候会输出什么到控制台，为什么？ 无论点击哪个按钮，数字5将总会输出到控制台。这是因为，当 onclick 方法被调用（对于任何按钮）的时候， for 循环已经结束，变量 i 已经获得了5的值 2）提供一个或多个备用的可按预期工作的实现方案。 要让代码工作的关键是，通过传递到一个新创建的函数对象，在每次传递通过 for 循环时，捕捉到 i 值。下面是三种可能实现的方法：12345btn.addEventListener('click', (function(i) &#123; return function() &#123; console.log(i) &#125;&#125;)(i)) 12345(function(i) &#123; brn.addEventListener('click', function() &#123; console.log(i) &#125;)&#125;)(i) 123456['a', 'b', 'c', 'd', 'e'].forEach(function (value, i) &#123; let btn = document.createElement('button') btn.appendChild(document.createTextNode('button ' + i)) btn.addEventListener('click', function() &#123; console.log(i) &#125;) document.body.appendChild(btn)&#125;); 12、下面的代码输出什么到控制台，为什么？123456let arr1 = 'john'.split('')let arr2 = arr1.reverse()let arr3 = 'jones'.split('')arr2.push(arr3)console.log('arr1.length: ' + arr1.length + ' last=' + arr1.slice(-1))console.log('arr2.length: ' + arr2.length + ' last=' + arr2.slice(-1)) 结果如下：12arr1.length: last=j,o,n,e,sarr2.length: last=j,o,n,e,s \barr1和arr2执行完后，两者相同，原因如下： 调用数组对象的 reverse() 方法并不只返回反顺序的阵列，它也反转了数组本身的顺序 reverse() 方法返回一个到数组本身的引用（在这种情况下即，arr1）。其结果为，arr2 仅仅是一个到 arr1的引用（而不是副本）。因此，当对 arr2做了任何事情（即当我们调用 arr2.push(arr3);）时，arr1 也会受到影响，因为 arr1 和 arr2 引用的是同一个对象。 13、下面的代码输出什么到控制台？为什么？123456console.log(1 + '2' + '2')console.log(1 + +'2' + '2')console.log(1 + -'1' + '2')console.log(+'1' + '1' + '2')console.log( 'A' - 'B' + '2')console.log( 'A' - 'B' + 2) 结果如下：123456\b1223202112NaN2NaN","tags":[]},{"title":"移动端webApp踩坑之记","date":"2017-07-06T15:32:02.000Z","path":"2017/07/06/移动端webApp踩坑之记/","text":"记录一下最近移动端webApp项目开发中，遇到的一些坑。 一、WebView 性能优化1. WebView的启动到js解析，编译，执行，消耗的时间比较久，然后呈现在眼前就是这么几个状态： 交互无反馈 到达新的页面，页面白屏 页面基本框架出现，但是没有数据；页面处于loading状态 最后出现所需的数据 解决思路： h5做的是单页面，所以h5首先做了按需加载，接着WebView也做了按需加载，这样就快很多了，时间大概在1-2s， 刚启动的时候就补了个动画页弥补这1-2s的加载 原生和h5都需要做本地缓存使页面和图片呈现的更快，再做数据请求更新 2. 点击延迟在WebView中，click通常会有大约300ms的延迟（包括链接的点击，表单的提交，控件的交互等任何用户点击行为）。 解决思路参考链接: fastclick 二、在ios中，输入状态时，h5定位属性fixed失效```12345678910111213141516171819&lt;div&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header class=\"header\"&gt; 我是头部 &lt;/header&gt; &lt;!-- 可以滚动的区域 --&gt; &lt;main class=\"main\"&gt; &lt;!-- 内容在这里... --&gt; &lt;/main&gt; &lt;!-- fixed定位的底部 --&gt; &lt;footer class=\"footer\"&gt; &lt;div class=\"textarea needsclick\" contentEditable=\"true\" suppressContentEditableWarning&gt;&lt;/div&gt; &lt;button onclick=\"handleClick()\"&gt;发送&lt;/button&gt; &lt;/footer&gt;&lt;/div&gt; 网上也查得到相关解决方案比如：http://efe.baidu.com/blog/mobile-fixed-layout/但是我也不知道为什么我按这个思路来，还是解决不了这个问题，有些人说可以解决，有些人说解决不了，就是这么的奇葩，或许是我姿势不对吧。=_=!! so，还是自己尝试摸索解决，我的布局header和footer是fixed，中间可滚动的区域是relative，算了不说了，直接上代码吧。12345678910111213141516171819202122232425262728// listenFocus和listenBlur是给可编辑div添加的聚焦和失焦的事件监听listenFocus = () =&gt; &#123; if (isiOS) &#123; let clientHeight = document.querySelector('.main').clientHeight // 高保真给的是2x的图，头部和底部的高度都是100px，所以中间的可视高度如下 let availHeight = (clientHeight - 200) / 2 // 此定位解决方案，当内容达不到滚动时，输入框就会移动，所以判断下内容高度是否达到滚动条件 if (availHeight &gt; window.screen.availHeight) &#123; // 巨坑啊！fuck this！fixed属性失效，千辛万苦摸索定位解决 document.querySelector('.footer').style.position = 'relative' document.querySelector('.main').style.paddingBottom = '0' &#125; // 原生键盘弹起后, 操作时高度会不一样，使输入框始终不会被键盘遮挡 timerId = setInterval(function() &#123; document.body.scrollTop = document.body.scrollHeight &#125;, 100) &#125;&#125; listenBlur = () =&gt; &#123; if (isiOS) &#123; let clientHeight = document.querySelector('.main').clientHeight let availHeight = (clientHeight - 200) / 2 if (availHeight &gt; window.screen.availHeight) &#123; document.querySelector('.footer').style.position = 'fixed' document.querySelector('.main').style.paddingBottom = '1rem' &#125; clearInterval(timerId) &#125; 建议移动端大多用flex布局","tags":[]},{"title":"Hello World","date":"2017-01-05T14:59:57.000Z","path":"2017/01/05/hello-world/","text":"在朋友的介绍下，这个博客很快就搭建起来了。 当看见它加载下来的时候，内心还是很喜悦的，有了自己的一小块领地，这种感觉很奇妙，现在想想都还有点小刺激呢。对我这种语文是体育老师教的宝宝，想想要写作，我就不自觉的在偷笑，啊哈哈 =_=好记性不如烂笔头，请打开学习旅程吧！ 当然这个色调和主题甚是喜欢啊，感谢litten大虾的神作。","tags":[]}]